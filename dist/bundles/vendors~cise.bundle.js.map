{"version":3,"sources":["webpack:///./node_modules/avsdf-base/avsdf-base.js","webpack:///./node_modules/cose-base/cose-base.js","webpack:///./node_modules/cytoscape-cise/cytoscape-cise.js","webpack:///./node_modules/layout-base/layout-base.js"],"names":["factory","__WEBPACK_EXTERNAL_MODULE_0__","modules","installedModules","__webpack_require__","moduleId","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","LGraph","AVSDFCircle","parent","graphMgr","vObject","this","inOrder","undefined","currentIndex","nodeSeparation","stack","perimeter","centerX","centerY","radius","create","initOrdering","getOrder","getCenterX","getCenterY","getRadius","getSize","getNodes","length","getTotalCrossingOfCircle","crossingNumber","node","nodeCrossing","getTotalCrossingOfEdges","hasFinishedOrdering","getNodeSeparation","setNodeSeparation","correctAngles","self","forEach","putInOrder","nodes","found","id","setIndex","setAngle","getAngle","Math","PI","getDiagonal","findNodeToPlace","sDegreeNode","findUnorderedSmallestDegreeNode","foundUnorderNode","pop","isOrdered","neighbors","getNeighborsSortedByDegree","neighbor","push","calculateRadius","totalDiagonal","sqrt","getWidth","getHeight","getParent","setWidth","setHeight","setCenter","calculateEdgeCrossingsOfNodes","calculateTotalCrossing","loadOldIndicesOfNodes","reOrderVertices","getIndex","minDegree","Number","MAX_SAFE_INTEGER","getDegree","LayoutConstants","AVSDFConstants","prop","DEFAULT_NODE_SEPARATION","LEdge","AVSDFEdge","source","target","vEdge","properties","getOtherEnd","crossesWithEdge","otherEdge","sourcePos","getSource","targetPos","getTarget","otherSourcePos","otherTargetPos","otherSourceDist","getCircDistWithTheNode","otherTargetDist","thisTargetDist","max","min","crossingWithEdge","calculateTotalCrossingWithList","edgeList","totalCrossing","edge","LNode","AVSDFNode","gm","vNode","loc","size","angle","circleIndex","totalCrossingOfEdges","isCrossingNumberValid","Quicksort","getCircle","getOwner","index","result","Array","from","getNeighborsList","filter","sort","a","b","getEdges","refNode","otherIndex","diff","getCrossingNumberWithNode","otherNode","temp_crossing_count","temp_edge_list","apply","ele","indexOf","Layout","AVSDFLayout","newGraph","avsdfCircle","graphManager","newNode","newEdge","getPositionsData","allNodes","getAllNodes","pData","rect","x","y","w","width","h","height","layout","getGraphs","clusterGraph","updateNodeAngles","getRoot","updateNodeCoordinates","cos","sin","initPostProcess","list","oneStepPostProcess","currentCrossingNumber","newCrossingNumber","neighbours","j","neighbour","oldIndex","newIndex","temp","avsdfBase","layoutBase","FDLayoutConstants","CoSEConstants","DEFAULT_USE_MULTI_LEVEL_SCALING","DEFAULT_RADIAL_SEPARATION","DEFAULT_EDGE_LENGTH","DEFAULT_COMPONENT_SEPERATION","TILE","TILING_PADDING_VERTICAL","TILING_PADDING_HORIZONTAL","FDLayoutEdge","CoSEEdge","CoSEGraph","vGraph","LGraphManager","CoSEGraphManager","FDLayoutNode","IMath","CoSENode","move","getLayout","displacementX","coolingFactor","springForceX","repulsionForceX","gravitationForceX","noOfChildren","displacementY","springForceY","repulsionForceY","gravitationForceY","abs","maxNodeDisplacement","sign","child","moveBy","propogateDisplacementToChildren","totalDisplacement","dX","dY","getChild","setPred1","pred1","getPred1","getPred2","pred2","setNext","next","getNext","setProcessed","processed","isProcessed","FDLayout","Point","PointD","Integer","IGeometry","Transform","CoSELayout","toBeTiled","newGraphManager","initParameters","arguments","isSubLayout","idealEdgeLength","useSmartIdealEdgeLengthCalculation","DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION","springConstant","DEFAULT_SPRING_STRENGTH","repulsionConstant","DEFAULT_REPULSION_STRENGTH","gravityConstant","DEFAULT_GRAVITY_STRENGTH","compoundGravityConstant","DEFAULT_COMPOUND_GRAVITY_STRENGTH","gravityRangeFactor","DEFAULT_GRAVITY_RANGE_FACTOR","compoundGravityRangeFactor","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","prunedNodesAll","growTreeIterations","afterGrowthIterations","isTreeGrowing","isGrowthFinished","coolingCycle","maxCoolingCycle","maxIterations","CONVERGENCE_CHECK_PERIOD","finalTemperature","coolingAdjuster","DEFAULT_CREATE_BENDS_AS_NEEDED","createBendpoints","resetAllEdges","level","classicLayout","nodesWithGravity","calculateNodesToApplyGravitationTo","setAllNodesToApplyGravitation","calcNoOfChildrenForAllNodes","calcLowestCommonAncestors","calcInclusionTreeDepths","calcEstimatedSize","calcIdealEdgeLengths","incremental","forest","getFlatForest","positionNodesRadially","reduceTrees","resetAllNodesToApplyGravitation","Set","intersection","has","positionNodesRandomly","initSpringEmbedder","runSpringEmbedder","tick","totalIterations","isConverged","layoutQuality","initialCoolingFactor","pow","log","animationPeriod","ceil","initialAnimationPeriod","updateBounds","updateGrid","growTree","DEFAULT_COOLING_FACTOR_INCREMENTAL","gridUpdateAllowed","forceToNodeSurroundingUpdate","calcSpringForces","calcRepulsionForces","calcGravitationalForces","moveNodes","animate","layoutEnded","ANIMATE","emit","graph","nodeList","graphs","updateConnected","isConnected","concat","edges","getAllEdges","visited","getBendpoints","createDummyNodesForBendpoints","add","getEdgeListToNode","k","multiEdge","currentStartingPoint","numberOfColumns","currentY","currentX","point","tree","centerNode","findCenterOfTree","radialLayout","floor","transform","WORLD_CENTER_X","WORLD_CENTER_Y","startingPoint","radialSep","maxDiagonalInTree","branchRadialLayout","bounds","calculateBounds","setDeviceOrgX","getMinX","setDeviceOrgY","getMinY","setWorldOrgX","setWorldOrgY","bottomRight","getMaxX","getMaxY","inverseTransformPoint","parentOfNode","startAngle","endAngle","distance","radialSeparation","halfInterval","teta","TWO_PI","x_","y_","neighborEdges","childCount","startIndex","branchCount","incEdgesCount","getEdgesBetween","splice","stepAngle","currentNeighbor","childStartAngle","childEndAngle","maxDiagonal","MIN_VALUE","diagonal","calcRepulsionRange","groupZeroDegreeMembers","tempMemberGroups","memberGroups","idToDummyNode","zeroDegree","getNodeDegreeWithChildren","getToBeTiled","p_id","keys","dummyCompoundId","dummyCompound","paddingLeft","paddingRight","paddingBottom","paddingTop","dummyParentGraph","getGraphManager","parentGraph","remove","clearCompounds","childGraphMap","idToNode","performDFSOnCompounds","compoundOrder","resetAllNodes","tileCompoundMembers","clearZeroDegreeMembers","tiledZeroDegreePack","compoundNode","tileNodes","repopulateCompounds","lCompoundNode","horizontalMargin","verticalMargin","adjustLocations","tiledMemberPack","repopulateZeroDegreeMembers","tiledPack","childGraph","children","theChild","getNodeDegree","degree","fillCompexOrderByDFS","organization","compoundHorizontalMargin","compoundVerticalMargin","left","rows","row","maxHeight","lnode","horizontalPadding","verticalPadding","minWidth","rowWidth","rowHeight","n1","n2","lNode","insertNodeToRow","canAddHorizontal","getShortestRowIndex","shiftToLastRow","rowIndex","minCompoundSize","extraHeight","r","MAX_VALUE","getLongestRowIndex","extraWidth","sri","add_to_row_ratio","add_new_row_ratio","hDiff","longest","last","instance","prevTotal","finalTotal","tilingPreLayout","tilingPostLayout","containsLeaf","prunedNodesInStepTemp","isInterGraph","prunedNodesInStep","nodeData","findPlaceforPrunedNode","gridForPrunedNode","nodeToConnect","prunedNode","startGridX","startX","finishGridX","finishX","startGridY","startY","finishGridY","finishY","controlRegions","grid","minCount","minIndex","random","coseBase","__WEBPACK_EXTERNAL_MODULE_3__","CiSEConstants","DEFAULT_IDEAL_INTER_CLUSTER_EDGE_LENGTH_COEFF","DEFAULT_ALLOW_NODES_INSIDE_CIRCLE","DEFAULT_MAX_RATIO_OF_NODES_INSIDE_CIRCLE","DEFAULT_INNER_EDGE_LENGTH","MAX_ROTATION_ANGLE","MIN_ROTATION_ANGLE","SWAP_IDLE_DURATION","SWAP_PREPERATION_DURATION","SWAP_PERIOD","SWAP_HISTORY_CLEARANCE_PERIOD","MIN_DISPLACEMENT_FOR_SWAP","REVERSE_PERIOD","assign","bind","tgt","_len","srcs","_key","src","NeedlemanWunsch","CircularForce","CiSEInterClusterEdgeInfo","CiSEInterClusterEdgeSort","CiSECircle","intraClusterEdges","interClusterEdges","inNodes","outNodes","onCircleNodes","inCircleNodes","orderMatrix","mayBeReversed","setRadius","getInNodes","getOutNodes","getOnCircleNodes","getInCircleNodes","setMayNotBeReversed","getMayBeReversed","getChildAt","getInterClusterEdges","edgesToAdd","getOnCircleNodeExt","getIntraClusterEdges","isIntraEdge","calculateParentNodeDimension","maxOnCircleNodeDimension","MIN_SAFE_INTEGER","dimension","margin","parentNode","computeOrderMatrix","N","_i","angleDiff","rotate","noOfNodes","rotationAmount","theta","onCircleNodeExt","updatePosition","nodeA","nodeB","getThisEnd","sourceNode","targetNode","decomposeForce","circularForce","ownerNode","Cx","Cy","Nx","Ny","Fx","Fy","C_angle","angleOfVector","F_angle","C_rev_angle","isRotationClockwise","angle_diff","F_magnitude","R_magnitude","swapNodes","first","second","smallIndexNode","bigIndexNode","firstExt","secondExt","getPrevNode","tempNode","smallIndexNodeExt","bigIndexNodeExt","smallIndexPrevNode","getHalfTheDiagonal","tempIndex","updateSwappingConditions","getNextNode","checkAndReverseIfReverseIsBetter","interClusterEdgeInfos","clusterCenter","getCenter","interClusterEdge","endInThisCluster","centerOfEndInOtherCluster","nodeCount","interClusterEdgeDegree","noOfOnCircleNodesToBeRepeated","_i2","nodeCountWithRepetitions","clusterNodes","reversedClusterNodes","_i3","getCharCode","neighborNodes","_i4","getEdge","alignmentScoreCurrent","computeAlignmentScore","alignmentScoreReversed","reverseNodes","charArrayReader1","charArrayReader2","getScore","noOfNodesOnCircle","nodeExt","reCalculateNodeAnglesAndPositions","moveOnCircleNodeInside","setAsNonOnCircleNode","reCalculateCircleSizeAndRadius","inOrderCopy","parentCenterX","parentCenterY","previousNode","CiSEEdge","isIntraCluster","other","sourceExt","targetExt","otherSourceExt","otherTargetExt","CiSEGraphManager","nonOnCircleNodes","getNonOnCircleNodes","setOnCircleNodes","setInCircleNodes","setNonOnCircleNodes","_createClass","defineProperties","props","descriptor","writable","key","Constructor","protoProps","staticProps","ownerCircle","A","TypeError","_classCallCheck","_quicksort","q","_partition","_get","compareFunction","_swap","_set","HashMap","DimensionD","CiSENode","CiSEOnCircleNodePair","CiSELayout","INCREMENTAL","idealInterClusterEdgeLengthCoefficient","allowNodesInsideCircle","maxRatioOfNodesInsideCircle","step","STEP_NOT_STARTED","phase","PHASE_NOT_STARTED","swappedPairsInLastIteration","iterations","oldTotalDisplacement","STEP_1","STEP_2","STEP_3","STEP_4","STEP_5","PHASE_SWAP_PREPERATION","PHASE_PERFORM_SWAP","PHASE_OTHER","newCircleLGraph","newCiSEOnCircleNode","setAsOnCircleNode","convertToClusteredGraph","clusters","_this","idToLNode","rootGraph","idToCytoscapeNode","put","data","cIDs","cID","_loop","clusterNode","setClusterId","circle","nodeID","cytoNode","dimensions","layoutDimensions","nodeDimensionsIncludeLabels","ciseNode","position","parseFloat","setId","getId","_loop2","clustered","cluster","includes","_CiSENode","e","sourceClusterID","getClusterId","targetClusterID","ciseEdge","_i5","_circle","_index","_circle2","_index2","doStep1","ciseToAvsdf","allGraphs","avsdfLayout","addRoot","clusteredNodes","_i6","ciseOnCircleNode","avsdfNode","getLocation","setLocation","allEdges","_i7","avsdfSource","avsdfTarget","avsdfEdge","sortedByDegreeList","_i8","_i9","_ciseOnCircleNode","_avsdfNode","_loc","parentCiSE","parentAVSDF","doStep2","newCoSENodes","newCoSEEdges","ciseNodeToCoseNode","coseEdgeToCiseEdges","coseLayout","useMultiLevelScaling","useFRGridVariant","coseRoot","nodePairs","_i10","_i11","sourceCise","targetCise","sourceCose","targetCose","sourceIndex","targetIndex","runLayout","_i12","_ciseNode","_loc2","_i13","_ciseNode2","_loc3","parentLoc","step3Init","step4Init","step5Init","runSpringEmbedderTick","iterationInPeriod","calcTotalForces","prepareCirclesForReversal","isPolishingStep","lEdges","idealLength","lNodes","_i14","calcSpringForce","calcRepulsionForce","_i15","inCircleNode","childNodes","_i16","childCiSENode","_lNodes","calcGravitationalForce","_i17","_node","_i18","_node2","values","addDisplacementForSwap","getRotationAmount","getDisplacementX","getDisplacementY","_i19","ciseOnCircleNodes","nonSafePairs","safePairs","swappedNodes","swappedPairs","firstNode","secondNode","firstNodeExt","secondNodeExt","firstNodeDisp","secondNodeDisp","discrepancy","_i20","canSwapWithNext","canSwapWithPrev","getDisplacementForSwap","pair","nonSafePair","lookForSwap","rollback","getDiscrepancy","getFirstNode","getSecondNode","isSwappedPreviously","int1","getInterClusterIntersections","swap","int2","inSameDirection","_i21","safePair","_i22","_i23","setDisplacementForSwap","swappedPair","nodeIterator","findAndMoveInnerNodes","ciseCircle","innerNodeCount","maxInnerNodes","innerNode","findInnerNode","moveInnerNode","onCircleNodeCount","sortedNodes","candidateNode","circleSegment","findMinimalSpanningSegment","connectedToNonImmediate","_i24","spanningNode","neighborOfSpanningNode","spanningIndex","neighborOfSpanningIndex","indexDiff","onCircleNodesList","segment","orderedNeigbors","getOnCircleNeighbors","orderedNodes","shortestSegmentStartNode","shortestSegmentEndNode","shortestSegmentLength","segmentLength","neighSize","tempSegmentStartNode","tempSegmentEndNode","tempSegmentLength","segmentEndReached","currentNode","nextIndex","CiSEOnCircleNodeExt","clusterID","ID","getLimitedDisplacement","displacement","MAX_NODE_DISPLACEMENT","onCircleNeighbors","getNoOfChildren","reset","orderIndex","canSwapWithPrevious","displacementForSwap","getCiseNode","String","fromCharCode","totalNodes","nextNodeIndex","getNextNodeExt","prevNextNodeExt","displacementIncrForSwap","ownerGraph","parentX","parentY","xDifference","yDifference","intraEdges","count","currentNodeIndex","nextNodeExt","tempCrossingNumber","prevNodeExt","swapWith","neighborExt","thisInterClusterEdges","otherInterClusterEdges","point1","point2","point3","point4","doIntersect","edgesOfNode","inSameDir","compareTo","equals","hashCode","toString","label","setRotationAmount","setDisplacementX","setDisplacementY","impl","register","cytoscape","ContinuousLayout","defaults","_ContinuousLayout","options","ReferenceError","_possibleConstructorReturn","__proto__","getPrototypeOf","springCoeff","nodeRepulsion","gravity","gravityRange","subClass","superClass","constructor","setPrototypeOf","_inherits","state","ciseLayout","root","estimatedSize","right","bottom","top","initializerIndex","isDone","isStepDone","timeToSwitchNextStep","_this2","getScratch","location","receiver","Function","desc","getOwnPropertyDescriptor","freeze","refresh","maxSimulationTime","ungrabifyWhileSimulating","fit","padding","boundingBox","ready","stop","randomize","infinite","makeBoundingBox","_require","setInitialPositionState","refreshPositions","getNodePositionData","multitick","eles","tickIndex","firstUpdate","animateEnd","animateContinuously","el","scratch","startTime","Date","now","running","currentBoundingBox","cy","one","prerun","onGrab","_ref","grabbed","onFree","onDrag","_ref2","tp","onNotDone","requestAnimationFrame","_frame","_onDone","grabbable","grabify","removeListener","unlistenToGrab","ungrabify","on","listenToGrab","done","_onNotDone","_onDone2","layoutPositions","pd","postrun","bb","x1","y1","x2","y2","round","locked","positions","nop","tickIndicatesDone","onDone","QUALITY","DEFAULT_INCREMENTAL","DEFAULT_ANIMATION_ON_LAYOUT","DEFAULT_ANIMATION_DURING_LAYOUT","DEFAULT_ANIMATION_PERIOD","DEFAULT_UNIFORM_LEAF_NODE_SIZES","DEFAULT_GRAPH_MARGIN","NODE_DIMENSIONS_INCLUDE_LABELS","SIMPLE_NODE_SIZE","SIMPLE_NODE_HALF_SIZE","EMPTY_COMPOUND_NODE_SIZE","MIN_EDGE_LENGTH","WORLD_BOUNDARY","INITIAL_WORLD_BOUNDARY","LGraphObject","isOverlapingSourceAndTarget","vGraphObject","bendpoints","getLength","getLca","lca","getSourceInLca","sourceInLca","getTargetInLca","targetInLca","getOtherEndInGraph","otherEnd","updateLength","clipPointCoordinates","getIntersection","getRect","lengthX","lengthY","updateLengthSimple","RectangleD","RandomSeed","inclusionTreeDepth","owner","setRect","upperLeft","cx","dx","dy","to","withChildren","withNeighborsList","getEstimatedSize","scatter","randomCenterX","randomCenterY","minX","maxX","nextDouble","minY","maxY","getLeft","getTop","getRight","getBottom","labelWidth","labelHeight","labelPos","getInclusionTreeDepth","trans","leftTop","vLeftTop","getX","getY","setX","setY","getDifference","pt","getCopy","translate","dim","LinkedList","obj2","obj1","obj","edgesToBeRemoved","slice","updateLeftTop","nodeTop","nodeLeft","recursive","nodeRight","nodeBottom","boundingRect","queue","shift","noOfVisitedInThisGraph","visitedNode","ngraph","nnode","setRootGraph","sourceGraph","targetGraph","lObj","nodesToBeRemoved","allNodesToApplyGravitation","getAllNodesToApplyGravitation","isOneAncestorOfOther","sourceAncestorGraph","targetAncestorGraph","calcLowestCommonAncestor","firstOwnerGraph","secondOwnerGraph","depth","includesInvalidEdge","MAX_ITERATIONS","DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION","COOLING_ADAPTATION_FACTOR","ADAPTATION_LOWER_NODE_LIMIT","ADAPTATION_UPPER_NODE_LIMIT","MAX_NODE_DISPLACEMENT_INCREMENTAL","MIN_REPULSION_DIST","PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR","GRID_CALCULATION_CHECK_PERIOD","calcSeparationAmount","rectA","rectB","overlapAmount","separationBuffer","intersects","directions","decideDirectionsForOverlappingNodes","slope","moveByY","moveByX","getIntersection2","p1x","p1y","p2x","p2y","topLeftAx","topLeftAy","topRightAx","bottomLeftAx","bottomLeftAy","bottomRightAx","halfWidthA","getWidthHalf","halfHeightA","getHeightHalf","topLeftBx","topLeftBy","topRightBx","bottomLeftBx","bottomLeftBy","bottomRightBx","halfWidthB","halfHeightB","clipPointAFound","clipPointBFound","slopeA","slopeB","slopePrime","cardinalDirectionA","cardinalDirectionB","tempPointAx","tempPointAy","tempPointBx","tempPointBy","getCardinalDirection","line","s1","s2","f1","f2","a1","a2","b1","b2","c1","c2","denom","x3","y3","x4","y4","atan","ONE_AND_HALF_PI","HALF_PI","p1","p2","p3","p4","det","lambda","gamma","THREE_PI","nodeFrom","prev","head","tail","_remove","vals","v","val","current","parseInt","_typeof","Symbol","iterator","UniqueIDGeneretor","lastID","createID","isPrimitive","uniqueID","getString","arg","type","_toConsumableArray","arr","isArray","arr2","Emitter","isRemoteUse","createBendsAsNeeded","animationOnLayout","animationDuringLayout","uniformLeafNodeSizes","edgeToDummyNodes","Map","isLayoutFinished","RANDOM_SEED","checkLayoutSuccess","isLayoutSuccessfull","doPostLayout","update","update2","createBendpointsFromDummyNodes","newLeftTop","flatForest","isForest","isFlat","toBeVisited","parents","unProcessedNodes","set","dummyNodes","dummyNode","Dimension","dummyEdge","lEdge","path","ebp","sliderValue","defaultValue","minDiv","maxMul","removedNodes","remainingDegrees","foundCenter","tempList","tempList2","newDegree","setGraphManager","seed","lworldOrgX","lworldOrgY","ldeviceOrgX","ldeviceOrgY","lworldExtX","lworldExtY","ldeviceExtX","ldeviceExtY","getWorldOrgX","wox","getWorldOrgY","woy","getWorldExtX","setWorldExtX","wex","getWorldExtY","setWorldExtY","wey","getDeviceOrgX","dox","getDeviceOrgY","doy","getDeviceExtX","setDeviceExtX","dex","getDeviceExtY","setDeviceExtY","dey","transformX","xDevice","worldExtX","transformY","yDevice","worldExtY","inverseTransformX","xWorld","deviceExtX","inverseTransformY","yWorld","deviceExtY","inPoint","displacementThresholdPerNode","notAnimatedIterations","lcaDepth","sizeOfSourceInLca","sizeOfTargetInLca","totalDisplacementThreshold","repulsionRange","processedNodeSet","calculateRepulsionForceOfANode","springForce","distanceX","distanceY","distanceSquared","repulsionForce","clipPoints","childrenConstant","ownerCenterX","ownerCenterY","absDistanceX","absDistanceY","converged","oscilating","calcGrid","sizeX","sizeY","addNodeToGrid","setGridCoordinates","surrounding","_startX","_finishX","_startY","_finishY","map","theId","contains","keySet","HashSet","clear","isEmpty","addAllTo","addAll","_defaultCompareFunction","get_object_at","set_object_at","sequence1","sequence2","match_score","mismatch_penalty","gap_penalty","iMax","jMax","tracebackGrid","_j","alignments","score","computeGrids","_j2","maxOf","indices","arrayAllMaxIndexes","inProcessAlignments","pos","seq1","seq2","indexes","array","getAllIndexes","listeners","addListener","event","callback"],"mappings":"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","file":"bundles/vendors~cise.bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"layout-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"layout-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"avsdfBase\"] = factory(require(\"layout-base\"));\n\telse\n\t\troot[\"avsdfBase\"] = factory(root[\"layoutBase\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class implements data and functionality required for AVSDF layout per\n * circle.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LGraph = __webpack_require__(0).LGraph;\n\n// -----------------------------------------------------------------------------\n// Section: Initializations\n// -----------------------------------------------------------------------------\n\nfunction AVSDFCircle(parent, graphMgr, vObject) {\n    LGraph.call(this, parent, graphMgr, vObject);\n    this.inOrder = undefined;\n    this.currentIndex = 0;\n    this.nodeSeparation = undefined;\n    this.stack = [];\n    this.perimeter = 0;\n    this.centerX = 0;\n    this.centerY = 0;\n    this.radius = 0;\n}\n\nAVSDFCircle.prototype = Object.create(LGraph.prototype);\n\nfor (var property in LGraph) {\n    AVSDFCircle[property] = LGraph[property];\n}\n\nAVSDFCircle.prototype.initOrdering = function () {\n    this.inOrder = [];\n};\n\n// -----------------------------------------------------------------------------\n// Section: Accessor Functions\n// -----------------------------------------------------------------------------\n\n// This function returns the array in which the nodes of this circle are kept in order.\nAVSDFCircle.prototype.getOrder = function () {\n    return this.inOrder;\n};\n\n// This function returns the x-coordinate of the center of this circle.\nAVSDFCircle.prototype.getCenterX = function () {\n    return this.centerX;\n};\n\n// This function returns the y-coordinate of the center of this circle.\nAVSDFCircle.prototype.getCenterY = function () {\n    return this.centerY;\n};\n\n// This function returns the radius of this circle.\nAVSDFCircle.prototype.getRadius = function () {\n    return this.radius;\n};\n\n// This function returns the total number of vertices of this circle.\nAVSDFCircle.prototype.getSize = function () {\n    return this.getNodes().length;\n};\n\n// This function calculates and returns the total number of crossings in this\n// circle by adding up the crossing number of individual nodes on it.\nAVSDFCircle.prototype.getTotalCrossingOfCircle = function () {\n    var self = this;\n    var crossingNumber = 0;\n\n    for (var node in self.inOrder) {\n        var nodeCrossing = node.getTotalCrossingOfEdges();\n        if (nodeCrossing === -1) {\n            return -1;\n        }\n        crossingNumber += nodeCrossing;\n    }\n\n    return crossingNumber / 4;\n};\n\n// This function checks whether or not all of the vertices of this circle are\n// assigned an index on the circle.\nAVSDFCircle.prototype.hasFinishedOrdering = function () {\n    return this.currentIndex === this.getNodes().length;\n};\n\n// This function returns the node separation of this circle.\nAVSDFCircle.prototype.getNodeSeparation = function () {\n    return this.nodeSeparation;\n};\n\n// This function sets the node separation of this circle.\nAVSDFCircle.prototype.setNodeSeparation = function (nodeSeparation) {\n    this.nodeSeparation = nodeSeparation;\n};\n\n// -----------------------------------------------------------------------------\n// Section: Remaining Functions\n// -----------------------------------------------------------------------------\n\n// This function traverses the vertices of this circle and corrects the angle\n// of the vertices with respect to their circle indices.\nAVSDFCircle.prototype.correctAngles = function () {\n    var self = this;\n    self.currentIndex = 0;\n\n    self.inOrder.forEach(function (node) {\n        return self.putInOrder(node);\n    });\n};\n\n// This function puts the given node on the circle in the current order and\n// sets its angle appropriately.\nAVSDFCircle.prototype.putInOrder = function (node) {\n    var self = this;\n\n    var nodes = self.getNodes();\n\n    // Note that id attribute of a node is added before\n    // AVSDFLayout is called\n    var found = false;\n    for (var i = 0; i < nodes.length; i++) {\n        if (nodes[i].id == node.id) {\n            found = true;\n            break;\n        }\n    }\n\n    if (!found) {\n        throw \"The node must be a member of LGraph\";\n    }\n\n    self.inOrder[self.currentIndex] = node;\n    node.setIndex(self.currentIndex);\n\n    if (self.currentIndex === 0) {\n        node.setAngle(0.0);\n    } else {\n        node.setAngle(self.inOrder[self.currentIndex - 1].getAngle() + 2 * Math.PI * (node.getDiagonal() / 2 + self.nodeSeparation + self.inOrder[self.currentIndex - 1].getDiagonal() / 2) / self.perimeter);\n    }\n\n    self.currentIndex++;\n};\n\n// This function returns the next node to be placed on this circle with\n// respect to the AVSDF algorithm.\nAVSDFCircle.prototype.findNodeToPlace = function () {\n    var self = this;\n    var sDegreeNode = undefined;\n\n    // Find the smallest degree vertex if the stack is empty\n    if (self.stack.length === 0) {\n        sDegreeNode = self.findUnorderedSmallestDegreeNode();\n    }\n    // Find the first vertex in the stack not yet placed\n    else {\n            var foundUnorderNode = false;\n\n            while (!foundUnorderNode && !(self.stack.length === 0)) {\n                sDegreeNode = self.stack.pop();\n                foundUnorderNode = !sDegreeNode.isOrdered();\n            }\n\n            if (!foundUnorderNode) {\n                sDegreeNode = undefined;\n            }\n        }\n\n    // If no unordered vertex is found in the stack, find one\n    // from the remaining ones\n    if (sDegreeNode === undefined) {\n        sDegreeNode = self.findUnorderedSmallestDegreeNode();\n    }\n\n    // Add the unordered neighbors of this node to the stack\n    if (sDegreeNode !== undefined) {\n        var neighbors = sDegreeNode.getNeighborsSortedByDegree();\n\n        for (var i = neighbors.length - 1; i >= 0; i--) {\n            var neighbor = neighbors[i];\n\n            if (!neighbor.isOrdered()) // Check here for possible error\n                {\n                    self.stack.push(neighbor);\n                }\n        }\n    }\n\n    return sDegreeNode;\n};\n\n// This function calculates the radius of this circle with respect to the sizes\n// of the vertices and the node separation parameter.\nAVSDFCircle.prototype.calculateRadius = function () {\n    var self = this;\n    var totalDiagonal = 0;\n\n    self.getNodes().forEach(function (node) {\n        return totalDiagonal += Math.sqrt(node.getWidth() * node.getWidth() + node.getHeight() * node.getHeight());\n    });\n\n    self.perimeter = totalDiagonal + self.getNodes().length * self.nodeSeparation;\n    var radius = self.perimeter / (2 * Math.PI);\n\n    // Check here for possible error\n\n    self.getParent().setWidth(2 * radius);\n    self.getParent().setHeight(2 * radius);\n    self.getParent().setCenter(self.getParent().getWidth(), self.getParent().getHeight());\n\n    self.centerX = self.getParent().getCenterX();\n    self.centerY = self.getParent().getCenterY();\n    self.radius = self.getParent().getHeight() / 2;\n};\n\n// This function calculates the total number of crossings of all vertices of\n// this circle.\nAVSDFCircle.prototype.calculateEdgeCrossingsOfNodes = function () {\n    this.getNodes().forEach(function (node) {\n        return node.calculateTotalCrossing();\n    });\n};\n\n// This function sets the index of each vertex to its position in inOrder\n// array. Note that index of a node can be different from its place in the\n// array due to crossing reduction phase of the AVSDF algorithm. It loads\n// old index values to vertices due to an increase in the number of\n// crossings with the new indices.\nAVSDFCircle.prototype.loadOldIndicesOfNodes = function () {\n    //this.inOrder.forEach( (node,index) => node.setIndex(index));\n    var self = this;\n    for (var i = 0; i < this.inOrder.length; i++) {\n        self.inOrder[i].setIndex(i);\n    }\n};\n\n// This function sets the position of each node in inOrder array to its index.\n// Note that index of a node can be different from its place in the inOrder\n// array due to crossing reduction phase of the AVSDF algorithm. This function\n// puts the nodes to their new index values in inOrder array due to a\n// decrease in the number of crossings with the new indices.\nAVSDFCircle.prototype.reOrderVertices = function () {\n    var self = this;\n    this.getNodes().forEach(function (node) {\n        return self.inOrder[node.getIndex()] = node;\n    });\n};\n\n// This function finds and returns the unordered smallest degree vertex on\n// this circle.\nAVSDFCircle.prototype.findUnorderedSmallestDegreeNode = function () {\n    var minDegree = Number.MAX_SAFE_INTEGER;\n    var sDegreeNode = void 0;\n\n    this.getNodes().forEach(function (node) {\n        if (node.getDegree() < minDegree && !node.isOrdered()) {\n            minDegree = node.getDegree();\n            sDegreeNode = node;\n        }\n    });\n\n    return sDegreeNode;\n};\n\nmodule.exports = AVSDFCircle;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __webpack_require__(0).LayoutConstants;\n\nfunction AVSDFConstants() {}\n\n// AVSDFConstants inherits properties in LayoutConstants\nfor (var prop in LayoutConstants) {\n    AVSDFConstants[prop] = LayoutConstants[prop];\n}\n\nAVSDFConstants.DEFAULT_NODE_SEPARATION = 60;\n\nmodule.exports = AVSDFConstants;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class implements data and functionality required for AVSDF layout per\n * edge.\n *\n\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LEdge = __webpack_require__(0).LEdge;\n\n// -----------------------------------------------------------------------------\n// Section: Initializations\n// -----------------------------------------------------------------------------\n\nfunction AVSDFEdge(source, target, vEdge) {\n    LEdge.call(this, source, target, vEdge);\n}\n\nAVSDFEdge.prototype = Object.create(LEdge.prototype);\n\nfor (var properties in LEdge) {\n    AVSDFEdge[properties] = LEdge[properties];\n}\n\n// -----------------------------------------------------------------------------\n// Section: Accessor Functions\n// -----------------------------------------------------------------------------\n\n// The function getOtherEnd returns the other end of this edge.\nAVSDFEdge.prototype.getOtherEnd = function (node) {\n    return LEdge.prototype.getOtherEnd(node);\n};\n\n// -----------------------------------------------------------------------------\n// Section: Remaining Functions\n// -----------------------------------------------------------------------------\n\n// This function checks whether this edge crosses with the input edge. It\n// returns false, if any of the vertices those edges are incident to are not\n// yet placed on the circle.\nAVSDFEdge.prototype.crossesWithEdge = function (otherEdge) {\n    var self = this;\n    var sourcePos = self.getSource().getIndex();\n    var targetPos = self.getTarget().getIndex();\n    var otherSourcePos = otherEdge.getSource().getIndex();\n    var otherTargetPos = otherEdge.getTarget().getIndex();\n\n    // if any of the vertices those two edges are not yet placed\n    if (sourcePos === -1 || targetPos === -1 || otherSourcePos === -1 || otherTargetPos === -1) {\n        return false;\n    }\n\n    var otherSourceDist = otherEdge.getSource().getCircDistWithTheNode(self.getSource());\n    var otherTargetDist = otherEdge.getTarget().getCircDistWithTheNode(self.getSource());\n    var thisTargetDist = self.getTarget().getCircDistWithTheNode(self.getSource());\n\n    if (thisTargetDist < Math.max(otherSourceDist, otherTargetDist) && thisTargetDist > Math.min(otherSourceDist, otherTargetDist) && otherTargetDist !== 0 && otherSourceDist !== 0) {\n        return true;\n    }\n\n    return false;\n};\n\n// This function returns 1 if this edge crosses with the input edge, 0\n// otherwise.\nAVSDFEdge.prototype.crossingWithEdge = function (otherEdge) {\n    var self = this;\n    var result = self.crossesWithEdge(otherEdge);\n\n    return result ? 1 : 0;\n};\n\n// This function calculates the total number of crossings of this edge with\n// all the edges given in the input list.\nAVSDFEdge.prototype.calculateTotalCrossingWithList = function (edgeList) {\n    var self = this;\n    var totalCrossing = 0;\n\n    edgeList.forEach(function (edge) {\n        return totalCrossing += self.crossingWithEdge(edge);\n    });\n\n    return totalCrossing;\n};\n\nmodule.exports = AVSDFEdge;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class implements data and functionality required for AVSDF layout per\n * node.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LNode = __webpack_require__(0).LNode;\nvar Quicksort = __webpack_require__(0).Quicksort;\n\n// -----------------------------------------------------------------------------\n// Section: Initializations\n// -----------------------------------------------------------------------------\n\nfunction AVSDFNode(gm, vNode, loc, size) {\n    // Constructor 1: AVSDFNode(gm, vNode, loc, size)\n    if (loc !== undefined && size !== undefined) {\n        LNode.call(this, gm, vNode, loc, size);\n    }\n    // Constructor 2: AVSDFNode(gm, vNode)\n    else {\n            LNode.call(this, gm, vNode);\n        }\n\n    // Angle of this node on the owner circle in radians\n    this.angle = 0;\n\n    // Index of this node on the owner circle\n    this.circleIndex = -1;\n\n    // Total number of crossings of the edges this node is incident to\n    this.totalCrossingOfEdges = -1;\n\n    // Whether the current edge crossing number is valid or it needs to be\n    // recalculated\n    this.isCrossingNumberValid = false;\n}\n\nAVSDFNode.prototype = Object.create(LNode.prototype);\nfor (var properties in LNode) {\n    AVSDFNode[properties] = LNode[properties];\n}\n\n// -----------------------------------------------------------------------------\n// Section: Accessor Functions\n// -----------------------------------------------------------------------------\n\n// This function returns the circle this node is owned by.\nAVSDFNode.prototype.getCircle = function () {\n    return this.getOwner();\n};\n\n// This function sets the index of this node on the circle, and sets the\n// crossing number invalid. Due to the index change of the node; it needs to\n// be recalculated.\nAVSDFNode.prototype.setIndex = function (index) {\n    this.circleIndex = index;\n    this.isCrossingNumberValid = false;\n};\n\n// This function returns the index of this node in the ordering of its owner\n// circle. Here -1 means that the vertex is not yet placed on its owner\n//circle.\nAVSDFNode.prototype.getIndex = function () {\n    return this.circleIndex;\n};\n\n// This function returns the array of the neigbors of this node sorted in\n// ascending order.\nAVSDFNode.prototype.getNeighborsSortedByDegree = function () {\n    var self = this;\n\n    var result = Array.from(self.getNeighborsList());\n    result = result.filter(function (node) {\n        return node.getIndex() === -1;\n    });\n\n    result.sort(function (a, b) {\n        return a.getDegree() - b.getDegree();\n    });\n\n    return result;\n};\n\n// This function returns the degree of this node.\nAVSDFNode.prototype.getDegree = function () {\n    return this.getEdges().length;\n};\n\n// This function returns whether or not this node is currently placed on its\n// owner circle.\nAVSDFNode.prototype.isOrdered = function () {\n    return this.getIndex() > -1;\n};\n\n// This function sets the angle of this node w.r.t. its owner circle. Here\n// the angle value is in radian.\nAVSDFNode.prototype.setAngle = function (angle) {\n    this.angle = angle;\n};\n\n// This function returns the angle of this node w.r.t. its owner circle. Here\n// the angle value is in radian.\nAVSDFNode.prototype.getAngle = function () {\n    return this.angle;\n};\n\n// This function returns the index difference of this node with the input\n// node. Note that the index difference cannot be negative if both nodes are\n// placed on the circle. Here -1 means at least one of the nodes are not yet\n// placed on the circle.\nAVSDFNode.prototype.getCircDistWithTheNode = function (refNode) {\n    var self = this;\n    var otherIndex = refNode.getIndex();\n\n    if (otherIndex === -1 || self.getIndex() === -1) {\n        return -1;\n    }\n\n    var diff = self.getIndex() - otherIndex;\n\n    if (diff < 0) {\n        diff += self.getCircle().getSize();\n    }\n\n    return diff;\n};\n\n// This function finds the number of edge crossings between the edges of\n// this node and the edges of the input one.\nAVSDFNode.prototype.getCrossingNumberWithNode = function (otherNode) {\n    var self = this;\n    var totalCrossing = 0;\n\n    self.getEdges().forEach(function (edge) {\n        otherNode.getEdges().forEach(function (otherEdge) {\n            totalCrossing += edge.crossingWithEdge(otherEdge);\n        });\n    });\n\n    return totalCrossing;\n};\n\n// This function returns the total number of edge crossings. If the previously\n// calculated value is not valid due to an index change on the circle, then\n// a recalculation is performed.\nAVSDFNode.prototype.getTotalCrossingOfEdges = function () {\n    var self = this;\n\n    if (!self.isCrossingNumberValid) {\n        self.calculateTotalCrossing();\n        self.isCrossingNumberValid = true;\n    }\n\n    return self.totalCrossingOfEdges;\n};\n\n// -----------------------------------------------------------------------------\n// Section: Remaining Functions\n// -----------------------------------------------------------------------------\n\n// This function calculates the total number of crossings the edges of this\n// node cause.\nAVSDFNode.prototype.calculateTotalCrossing = function () {\n    var self = this;\n    var temp_crossing_count = 0;\n    var temp_edge_list = [];\n    temp_edge_list.push.apply(temp_edge_list, self.getCircle().getEdges());\n    temp_edge_list = temp_edge_list.filter(function (ele) {\n        return self.getEdges().indexOf(ele) < 0;\n    });\n\n    self.getEdges().forEach(function (edge) {\n        return temp_crossing_count += edge.calculateTotalCrossingWithList(temp_edge_list);\n    });\n\n    self.totalCrossingOfEdges = temp_crossing_count;\n};\n\nmodule.exports = AVSDFNode;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class implements the overall layout process for the AVSDF algorithm\n * (Circular Drawing Algorithm by He and Sykora).\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar Layout = __webpack_require__(0).Layout;\nvar AVSDFConstants = __webpack_require__(2);\nvar AVSDFCircle = __webpack_require__(1);\nvar AVSDFNode = __webpack_require__(4);\nvar AVSDFEdge = __webpack_require__(3);\n\n// -----------------------------------------------------------------------------\n// Section: Initializations\n// -----------------------------------------------------------------------------\n\n// Constructor\nfunction AVSDFLayout() {\n    Layout.call(this);\n    this.nodeSeparation = AVSDFConstants.DEFAULT_NODE_SEPARATION;\n}\n\nAVSDFLayout.prototype = Object.create(Layout.prototype);\n\nfor (var property in Layout) {\n    AVSDFLayout[property] = Layout[property];\n}\n\nAVSDFLayout.prototype.newGraph = function (vObject) {\n    this.avsdfCircle = new AVSDFCircle(null, this.graphManager, vObject);\n\n    return this.avsdfCircle;\n};\n\nAVSDFLayout.prototype.newNode = function (vNode) {\n    return new AVSDFNode(this.graphManager, vNode);\n};\n\nAVSDFLayout.prototype.newEdge = function (vEdge) {\n    return new AVSDFEdge(null, null, vEdge);\n};\n\n// -----------------------------------------------------------------------------\n// Section: Accessor Functions\n// -----------------------------------------------------------------------------\n\n// This function returns the position data for all nodes\nAVSDFLayout.prototype.getPositionsData = function () {\n    var allNodes = this.graphManager.getAllNodes();\n    var pData = {};\n\n    for (var i = 0; i < allNodes.length; i++) {\n        var rect = allNodes[i].rect;\n        var id = allNodes[i].id;\n\n        pData[id] = {\n            id: id,\n            x: rect.getCenterX(),\n            y: rect.getCenterY(),\n            w: rect.width,\n            h: rect.height\n        };\n    }\n\n    return pData;\n};\n\n// -----------------------------------------------------------------------------\n// Section: Layout Related\n// -----------------------------------------------------------------------------\n\n/**\n * This function performs layout on constructed l-level graph.\n * It returns true on success, false otherwise.\n * Important!: If you want to see the results of this function then, after this function is called, you have to calculate\n * and set the positions of every node. To do this call updateNodeCoordinates. However, updateNodeAngles on the other\n * hand is not needed (redundant) for this function.\n */\nAVSDFLayout.prototype.layout = function () {\n    var self = this;\n\n    // Check if graph contains any compound structures\n    if (self.graphManager.getGraphs().length > 1) {\n        return false;\n    }\n\n    var clusterGraph = this.avsdfCircle; // Fixed reference, but now it is a bit redundant\n\n    clusterGraph.setNodeSeparation(this.nodeSeparation);\n    clusterGraph.calculateRadius();\n    clusterGraph.initOrdering();\n\n    while (!clusterGraph.hasFinishedOrdering()) {\n        var node = clusterGraph.findNodeToPlace();\n        clusterGraph.putInOrder(node);\n    }\n\n    return true;\n};\n\n// This function updates the angle (in radians) property of AVSDFNode elements in the circle\nAVSDFLayout.prototype.updateNodeAngles = function () {\n    this.graphManager.getRoot().correctAngles(); //AVSDFCircle object\n};\n\n// This function traverses the vertices of the graph and sets their correct coordinates with respect to the owner circle.\nAVSDFLayout.prototype.updateNodeCoordinates = function () {\n    var clusterGraph = this.graphManager.getRoot();\n\n    clusterGraph.getNodes().forEach(function (node) {\n        node.setCenter(clusterGraph.getCenterX() + clusterGraph.getRadius() * Math.cos(node.getAngle()), clusterGraph.getCenterY() + clusterGraph.getRadius() * Math.sin(node.getAngle()));\n    });\n};\n\n// -----------------------------------------------------------------------------\n// Section: Post Processing\n// -----------------------------------------------------------------------------\n\n/**\n * This method implements the post processing step of the algorithm, which\n * tries to minimize the number of edges further with respect to the local\n * adjusting algorithm described by He and Sykora.\n */\nAVSDFLayout.prototype.initPostProcess = function () {\n    this.avsdfCircle.calculateEdgeCrossingsOfNodes();\n\n    var list = this.avsdfCircle.getNodes();\n\n    list.sort(function (a, b) {\n        return b.getTotalCrossingOfEdges() - a.getTotalCrossingOfEdges();\n    });\n\n    return list;\n};\n\nAVSDFLayout.prototype.oneStepPostProcess = function (node) {\n    var self = this;\n\n    var currentCrossingNumber = node.getTotalCrossingOfEdges();\n    var newCrossingNumber = void 0;\n\n    var neighbours = Array.from(node.getNeighborsList());\n\n    for (var j = 0; j < neighbours.length; j++) {\n        var neighbour = neighbours[j];\n\n        var oldIndex = node.getIndex();\n        var newIndex = (neighbour.getIndex() + 1) % self.avsdfCircle.getSize();\n\n        if (oldIndex !== newIndex) {\n            node.setIndex(newIndex);\n\n            if (oldIndex < node.getIndex()) {\n                oldIndex += self.avsdfCircle.getSize();\n            }\n\n            var index = node.getIndex();\n\n            while (index < oldIndex) {\n                var temp = self.avsdfCircle.getOrder()[index % self.avsdfCircle.getSize()];\n                temp.setIndex((temp.getIndex() + 1) % self.avsdfCircle.getSize());\n                index += 1;\n            }\n\n            node.calculateTotalCrossing();\n            newCrossingNumber = node.getTotalCrossingOfEdges();\n\n            if (newCrossingNumber >= currentCrossingNumber) {\n                self.avsdfCircle.loadOldIndicesOfNodes();\n            } else {\n                self.avsdfCircle.reOrderVertices();\n                currentCrossingNumber = newCrossingNumber;\n            }\n        }\n    }\n};\n\nmodule.exports = AVSDFLayout;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar avsdfBase = {};\n\navsdfBase.layoutBase = __webpack_require__(0);\navsdfBase.AVSDFConstants = __webpack_require__(2);\navsdfBase.AVSDFEdge = __webpack_require__(3);\navsdfBase.AVSDFCircle = __webpack_require__(1);\navsdfBase.AVSDFLayout = __webpack_require__(5);\navsdfBase.AVSDFNode = __webpack_require__(4);\n\nmodule.exports = avsdfBase;\n\n/***/ })\n/******/ ]);\n});","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"layout-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"layout-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"coseBase\"] = factory(require(\"layout-base\"));\n\telse\n\t\troot[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutEdge = __webpack_require__(0).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraph = __webpack_require__(0).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphManager = __webpack_require__(0).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutNode = __webpack_require__(0).FDLayoutNode;\nvar IMath = __webpack_require__(0).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n  this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n  this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // a simple node, just move it\n  if (this.child == null) {\n    this.moveBy(this.displacementX, this.displacementY);\n  }\n  // an empty compound node, again just move it\n  else if (this.child.getNodes().length == 0) {\n      this.moveBy(this.displacementX, this.displacementY);\n    }\n    // non-empty compound node, propogate movement to children as well\n    else {\n        this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n      }\n\n  layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.moveBy(dX, dY);\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayout = __webpack_require__(0).FDLayout;\nvar CoSEGraphManager = __webpack_require__(4);\nvar CoSEGraph = __webpack_require__(3);\nvar CoSENode = __webpack_require__(5);\nvar CoSEEdge = __webpack_require__(2);\nvar CoSEConstants = __webpack_require__(1);\nvar FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\nvar LayoutConstants = __webpack_require__(0).LayoutConstants;\nvar Point = __webpack_require__(0).Point;\nvar PointD = __webpack_require__(0).PointD;\nvar Layout = __webpack_require__(0).Layout;\nvar Integer = __webpack_require__(0).Integer;\nvar IGeometry = __webpack_require__(0).IGeometry;\nvar LGraph = __webpack_require__(0).LGraph;\nvar Transform = __webpack_require__(0).Transform;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n    this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n\n    // variables for cooling\n    this.coolingCycle = 0;\n    this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n    this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n    this.coolingAdjuster = 1;\n  }\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  }\n\n  this.initSpringEmbedder();\n  this.runSpringEmbedder();\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n  x += compoundHorizontalMargin;\n  y += compoundVerticalMargin;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding\n  };\n\n  // Sort the nodes in ascending order of their areas\n  nodes.sort(function (n1, n2) {\n    if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n    if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n    return 0;\n  });\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n  var startGridX = nodeToConnect.startX;\n  var finishGridX = nodeToConnect.finishX;\n  var startGridY = nodeToConnect.startY;\n  var finishGridY = nodeToConnect.finishY;\n\n  var upNodeCount = 0;\n  var downNodeCount = 0;\n  var rightNodeCount = 0;\n  var leftNodeCount = 0;\n  var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n  if (startGridY > 0) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n    }\n  }\n  if (finishGridX < this.grid.length - 1) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n    }\n  }\n  if (finishGridY < this.grid[0].length - 1) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n    }\n  }\n  if (startGridX > 0) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n    }\n  }\n  var min = Integer.MAX_VALUE;\n  var minCount;\n  var minIndex;\n  for (var j = 0; j < controlRegions.length; j++) {\n    if (controlRegions[j] < min) {\n      min = controlRegions[j];\n      minCount = 1;\n      minIndex = j;\n    } else if (controlRegions[j] == min) {\n      minCount++;\n    }\n  }\n\n  if (minCount == 3 && min == 0) {\n    if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n      gridForPrunedNode = 1;\n    } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 0;\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 3;\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 2;\n    }\n  } else if (minCount == 2 && min == 0) {\n    var random = Math.floor(Math.random() * 2);\n    if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n      ;\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 1;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else {\n      if (random == 0) {\n        gridForPrunedNode = 2;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    }\n  } else if (minCount == 4 && min == 0) {\n    var random = Math.floor(Math.random() * 4);\n    gridForPrunedNode = random;\n  } else {\n    gridForPrunedNode = minIndex;\n  }\n\n  if (gridForPrunedNode == 0) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n  } else if (gridForPrunedNode == 1) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  } else if (gridForPrunedNode == 2) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n  } else {\n    prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __webpack_require__(0);\ncoseBase.CoSEConstants = __webpack_require__(1);\ncoseBase.CoSEEdge = __webpack_require__(2);\ncoseBase.CoSEGraph = __webpack_require__(3);\ncoseBase.CoSEGraphManager = __webpack_require__(4);\ncoseBase.CoSELayout = __webpack_require__(6);\ncoseBase.CoSENode = __webpack_require__(5);\n\nmodule.exports = coseBase;\n\n/***/ })\n/******/ ]);\n});","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"avsdf-base\"), require(\"cose-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"avsdf-base\", \"cose-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cytoscapeCise\"] = factory(require(\"avsdf-base\"), require(\"cose-base\"));\n\telse\n\t\troot[\"cytoscapeCise\"] = factory(root[\"avsdfBase\"], root[\"coseBase\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_3__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 15);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class maintains the constants used by CiSE layout.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar FDLayoutConstants = __webpack_require__(0).layoutBase.FDLayoutConstants;\n\nfunction CiSEConstants() {}\n\nfor (var prop in FDLayoutConstants) {\n    CiSEConstants[prop] = FDLayoutConstants[prop];\n}\n\n// -----------------------------------------------------------------------------\n// Section: CiSE layout user options\n// -----------------------------------------------------------------------------\n\nCiSEConstants.DEFAULT_SPRING_STRENGTH = 1.5 * FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n\n// Amount of separation of nodes on the associated circle\nCiSEConstants.DEFAULT_NODE_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 4;\n\n// Inter-cluster edge length factor (2.0 means inter-cluster edges should be\n// twice as long as intra-cluster edges)\nCiSEConstants.DEFAULT_IDEAL_INTER_CLUSTER_EDGE_LENGTH_COEFF = 1.4;\n\n// Whether to enable pulling nodes inside of the circles\nCiSEConstants.DEFAULT_ALLOW_NODES_INSIDE_CIRCLE = false;\n\n// Max percentage of the nodes in a circle that can be inside the circle\nCiSEConstants.DEFAULT_MAX_RATIO_OF_NODES_INSIDE_CIRCLE = 0.1;\n\n// -----------------------------------------------------------------------------\n// Section: CiSE layout remaining constants\n// -----------------------------------------------------------------------------\n\n// Ideal length of an edge incident with an inner-node\nCiSEConstants.DEFAULT_INNER_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 3;\n\n// Maximum rotation angle\nCiSEConstants.MAX_ROTATION_ANGLE = Math.PI / 36.0;\n\n// Minimum rotation angle\nCiSEConstants.MIN_ROTATION_ANGLE = -CiSEConstants.MAX_ROTATION_ANGLE;\n\n// Number of iterations without swap or swap prepartion\nCiSEConstants.SWAP_IDLE_DURATION = 45;\n\n// Number of iterations required for collecting information about swapping\nCiSEConstants.SWAP_PREPERATION_DURATION = 5;\n\n// Number of iterations that should be done in between two swaps.\nCiSEConstants.SWAP_PERIOD = CiSEConstants.SWAP_IDLE_DURATION + CiSEConstants.SWAP_PREPERATION_DURATION;\n\n// Number of iterations during which history (of pairs swapped) kept\nCiSEConstants.SWAP_HISTORY_CLEARANCE_PERIOD = 6 * CiSEConstants.SWAP_PERIOD;\n\n// Buffer for swapping\nCiSEConstants.MIN_DISPLACEMENT_FOR_SWAP = 6;\n\n// Number of iterations that should be done in between two flips.\nCiSEConstants.REVERSE_PERIOD = 25;\n\nmodule.exports = CiSEConstants;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Simple, internal Object.assign() polyfill for options objects etc.\n\nmodule.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    srcs[_key - 1] = arguments[_key];\n  }\n\n  srcs.forEach(function (src) {\n    Object.keys(src).forEach(function (k) {\n      return tgt[k] = src[k];\n    });\n  });\n\n  return tgt;\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n *\n * Choose the type of layout that best suits your usecase as a starting point.\n *\n * A discrete layout is one that algorithmically sets resultant positions.  It\n * does not have intermediate positions.\n *\n * A continuous layout is one that updates positions continuously, like a force-\n * directed / physics simulation layout.\n */\nmodule.exports = __webpack_require__(16);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class implements data and functionality required for CiSE layout per\n * cluster.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LGraph = __webpack_require__(0).layoutBase.LGraph;\nvar IGeometry = __webpack_require__(0).layoutBase.IGeometry;\nvar NeedlemanWunsch = __webpack_require__(0).layoutBase.NeedlemanWunsch;\nvar CircularForce = __webpack_require__(14);\nvar CiSEConstants = __webpack_require__(1);\nvar CiSEInterClusterEdgeInfo = __webpack_require__(8);\nvar CiSEInterClusterEdgeSort = __webpack_require__(9);\n\nfunction CiSECircle(parent, graphMgr, vNode) {\n    LGraph.call(this, parent, graphMgr, vNode);\n\n    // Holds the intra-cluster edges of this circle, initially it is null. It\n    // will be calculated and stored when getIntraClusterEdges method is first\n    // called.\n    this.intraClusterEdges = null;\n\n    // Holds the inter-cluster edges of this circle, initially it is null. It\n    // will be calculated and stored when getInterClusterEdges method is first\n    // called.\n    this.interClusterEdges = null;\n\n    // Holds the nodes which don't have neighbors outside this circle\n    this.inNodes = [];\n\n    // Holds the nodes which have neighbors outside this circle\n    this.outNodes = [];\n\n    // Holds the nodes which are on the circle\n    this.onCircleNodes = [];\n\n    // Holds the nodes which are inside the circle\n    this.inCircleNodes = [];\n\n    // The radius of this circle, calculated with respect to the dimensions of\n    // the nodes on this circle and node separation options\n    this.radius = 0;\n\n    // Holds the pairwise ordering of on-circle nodes computed in earlier stages\n    // of layout. Value at i,j means the following assuming u and v are\n    // on-circle nodes with orderIndex i and j, respectively. Value at i,j is\n    // true (false) if u and v are closer when we go from u to v in clockwise\n    // (counter-clockwise) direction. Here we base distance on the angles of the\n    // two nodes as opposed to their order indices (this might make a difference\n    // due to non-uniform node sizes).\n    this.orderMatrix = null;\n\n    // Whether or not this circle may be reserved for the purpose of improving\n    // inter-cluster edge crossing number as we do not want to redundantly\n    // reverse clusters and end up in oscillating situtations. Clusters with\n    // special circumstances (e.g. less than two inter-cluster edge) are set as\n    // may not be reversed as well.\n    this.mayBeReversed = true;\n}\n\nCiSECircle.prototype = Object.create(LGraph.prototype);\n\nfor (var prop in LGraph) {\n    CiSECircle[prop] = LGraph[prop];\n}\n\n// -----------------------------------------------------------------------------\n// Section: Accessors and mutators\n// -----------------------------------------------------------------------------\n// This method returns the radius of this circle.\nCiSECircle.prototype.setRadius = function (radius) {\n    this.radius = radius;\n};\n\n// This method sets the radius of this circle.\nCiSECircle.prototype.getRadius = function () {\n    return this.radius;\n};\n\n// This method returns nodes that don't have neighbors outside this circle.\nCiSECircle.prototype.getInNodes = function () {\n    return this.inNodes;\n};\n\n// This method returns nodes that have neighbors outside this circle.\nCiSECircle.prototype.getOutNodes = function () {\n    return this.outNodes;\n};\n\n// This method returns nodes that don't have neighbors outside this circle.\nCiSECircle.prototype.getOnCircleNodes = function () {\n    return this.onCircleNodes;\n};\n\n// This method returns nodes that don't have neighbors outside this circle.\nCiSECircle.prototype.getInCircleNodes = function () {\n    return this.inCircleNodes;\n};\n\nCiSECircle.prototype.setMayNotBeReversed = function () {\n    this.mayBeReversed = false;\n};\n\n// This method returns whether or not this circle has been reversed.\nCiSECircle.prototype.getMayBeReversed = function () {\n    return this.mayBeReversed;\n};\n\n// This method downcasts and returns the child at given index.\nCiSECircle.prototype.getChildAt = function (index) {\n    return this.onCircleNodes[index];\n};\n\n/**\n * This method returns the inter-cluster edges whose one end is in this\n * cluster.\n */\nCiSECircle.prototype.getInterClusterEdges = function () {\n    var self = this;\n\n    if (this.interClusterEdges === null) //If this is called the first time\n        {\n            this.interClusterEdges = [];\n            this.outNodes.forEach(function (node) {\n                var edgesToAdd = node.getOnCircleNodeExt().getInterClusterEdges();\n                for (var i = 0; i < edgesToAdd.length; i++) {\n                    self.interClusterEdges.push(edgesToAdd[i]);\n                }\n            });\n        }\n\n    return this.interClusterEdges;\n};\n\n/**\n * This method returns the intra cluster edges of this circle\n */\nCiSECircle.prototype.getIntraClusterEdges = function () {\n    var self = this;\n\n    if (this.intraClusterEdges === null) //If this is called the first time\n        {\n            this.intraClusterEdges = [];\n            var allEdges = this.getEdges();\n            allEdges.forEach(function (edge) {\n                if (edge.isIntraEdge()) self.intraClusterEdges.push(edge);\n            });\n        }\n\n    return this.intraClusterEdges;\n};\n\n// -----------------------------------------------------------------------------\n// Section: Other methods\n// -----------------------------------------------------------------------------\n\n// This method calculates and sets dimensions of the parent node of this\n// circle. Parent node is centered to be at the same location of the\n// associated circle but its dimensions are larger than the circle by a\n// factor (must be >= 1 to ensure all nodes are enclosed within its\n// rectangle) of the largest dimension (width or height) of on-circle nodes\n// so that it completely encapsulates the nodes on this circle.\nCiSECircle.prototype.calculateParentNodeDimension = function () {\n    var self = this;\n\n    var maxOnCircleNodeDimension = Number.MIN_SAFE_INTEGER;\n\n    for (var i = 0; i < this.onCircleNodes.length; i++) {\n        var node = this.onCircleNodes[i];\n\n        if (node.getWidth() > maxOnCircleNodeDimension) {\n            maxOnCircleNodeDimension = node.getWidth();\n        }\n        if (node.getHeight() > maxOnCircleNodeDimension) {\n            maxOnCircleNodeDimension = node.getHeight();\n        }\n    }\n\n    var dimension = 2.0 * (self.radius + self.margin) + maxOnCircleNodeDimension;\n    var parentNode = self.getParent();\n    parentNode.setHeight(dimension);\n    parentNode.setWidth(dimension);\n};\n\n/*\n * This method computes the order matrix of this circle. This should be\n * called only once at early stages of layout and is used to hold the order\n * of on-circle nodes as specified.\n */\nCiSECircle.prototype.computeOrderMatrix = function () {\n    var N = this.onCircleNodes.length;\n\n    // 'Two Dimensional array' (array of arrays in JS) with bool cell values\n    this.orderMatrix = new Array(N);\n    for (var i = 0; i < this.orderMatrix.length; i++) {\n        this.orderMatrix[i] = new Array(N);\n    }\n\n    for (var _i = 0; _i < N; _i++) {\n        for (var j = 0; j < N; j++) {\n            if (j > _i) {\n                var angleDiff = this.onCircleNodes[j].getOnCircleNodeExt().getAngle() - this.onCircleNodes[_i].getOnCircleNodeExt().getAngle();\n\n                if (angleDiff < 0) {\n                    angleDiff += IGeometry.TWO_PI;\n                }\n\n                if (angleDiff <= Math.PI) {\n                    this.orderMatrix[_i][j] = true;\n                    this.orderMatrix[j][_i] = false;\n                } else {\n                    this.orderMatrix[_i][j] = false;\n                    this.orderMatrix[j][_i] = true;\n                }\n            }\n        }\n    }\n};\n\n/**\n * This method rotates this circle by iterating over and adjusting the\n * relative positioning of all nodes on this circle by the calculated angle\n * with respect to the rotation amount of the owner node.\n */\nCiSECircle.prototype.rotate = function () {\n    // Take size into account when reflecting total force into rotation!\n    var parentNode = this.getParent();\n    var noOfNodes = this.getOnCircleNodes().length;\n    var rotationAmount = parentNode.rotationAmount / noOfNodes; // Think about the momentum\n    var layout = this.getGraphManager().getLayout();\n\n    if (rotationAmount !== 0.0) {\n        // The angle (θ) of rotation applied to each node\n        var theta = rotationAmount / this.radius;\n\n        if (theta > CiSEConstants.MAX_ROTATION_ANGLE) theta = CiSEConstants.MAX_ROTATION_ANGLE;else if (theta < CiSEConstants.MIN_ROTATION_ANGLE) theta = CiSEConstants.MIN_ROTATION_ANGLE;\n\n        for (var i = 0; i < noOfNodes; i++) {\n            var onCircleNode = this.getChildAt(i);\n            var onCircleNodeExt = onCircleNode.getOnCircleNodeExt();\n            onCircleNodeExt.setAngle(onCircleNodeExt.getAngle() + theta); // Change the angle\n            onCircleNodeExt.updatePosition(); // Apply the above angle change to its position\n        }\n\n        // Update CiSELayout displacement\n        layout.totalDisplacement += parentNode.rotationAmount;\n\n        // Reset rotationAmount\n        parentNode.rotationAmount = 0.0;\n    }\n};\n\n/**\n * This method returns the pairwise order of the input nodes as computed and\n * held in orderMatrix.\n */\nCiSECircle.prototype.getOrder = function (nodeA, nodeB) {\n    return this.orderMatrix[nodeA.getOnCircleNodeExt().getIndex()][nodeB.getOnCircleNodeExt().getIndex()];\n};\n\n/**\n * This method gets the end node of the input inter-cluster edge in this\n * cluster.\n */\nCiSECircle.prototype.getThisEnd = function (edge) {\n    var sourceNode = edge.getSource();\n    var targetNode = edge.getTarget();\n\n    if (sourceNode.getOwner() === this) return sourceNode;else return targetNode;\n};\n\n/**\n * This method gets the end node of the input inter-cluster edge not in this\n * cluster.\n */\nCiSECircle.prototype.getOtherEnd = function (edge) {\n    var sourceNode = edge.getSource();\n    var targetNode = edge.getTarget();\n\n    if (sourceNode.getOwner() === this) return targetNode;else return sourceNode;\n};\n\n/**\n * This method calculates and returns rotational and translational parts of\n * the total force calculated for the given node. The translational part is\n * composed of components in x and y directions.\n */\nCiSECircle.prototype.decomposeForce = function (node) {\n    var circularForce = void 0;\n\n    if (node.displacementX !== 0.0 || node.displacementY !== 0.0) {\n        var ownerNode = this.getParent();\n\n        var Cx = ownerNode.getCenterX();\n        var Cy = ownerNode.getCenterY();\n        var Nx = node.getCenterX();\n        var Ny = node.getCenterY();\n        var Fx = node.displacementX;\n        var Fy = node.displacementY;\n\n        var C_angle = IGeometry.angleOfVector(Cx, Cy, Nx, Ny);\n        var F_angle = IGeometry.angleOfVector(0.0, 0.0, Fx, Fy);\n        var C_rev_angle = C_angle + Math.PI;\n\n        // Check whether F lies between C and its opposite angle C-reverse;\n        // if so, rotation is +ve (clockwise); otherwise, it's -ve.\n        // We handle angles greater than 360 specially in the else part.\n        var isRotationClockwise = void 0;\n        if (Math.PI <= C_rev_angle && C_rev_angle < IGeometry.TWO_PI) {\n            isRotationClockwise = C_angle <= F_angle && F_angle < C_rev_angle;\n        } else {\n            C_rev_angle -= IGeometry.TWO_PI;\n\n            isRotationClockwise = !(C_rev_angle <= F_angle && F_angle < C_angle);\n        }\n\n        var angle_diff = Math.abs(C_angle - F_angle);\n        var F_magnitude = Math.sqrt(Fx * Fx + Fy * Fy);\n        var R_magnitude = Math.abs(Math.sin(angle_diff) * F_magnitude);\n\n        if (!isRotationClockwise) {\n            R_magnitude = -R_magnitude;\n        }\n\n        circularForce = new CircularForce(R_magnitude, Fx, Fy);\n    } else {\n        circularForce = new CircularForce(0.0, 0.0, 0.0);\n    }\n\n    return circularForce;\n};\n\n/**\n * This method swaps the nodes given as parameter and make necessary angle\n * and positioning updates.\n */\nCiSECircle.prototype.swapNodes = function (first, second) {\n    // Determine which node has smaller index\n    var smallIndexNode = first;\n    var bigIndexNode = second;\n    var firstExt = first.getOnCircleNodeExt();\n    var secondExt = second.getOnCircleNodeExt();\n\n    if (smallIndexNode.getOnCircleNodeExt().getIndex() > second.getOnCircleNodeExt().getIndex()) {\n        smallIndexNode = second;\n        bigIndexNode = first;\n    }\n\n    // Check the exceptional case where the small index node is at 0 index\n    // and the big index node is at the last index of the circle. In this\n    // case, we treat smaller index node as bigger index node and vice versa\n    if (smallIndexNode.getOnCircleNodeExt().getPrevNode() === bigIndexNode) {\n        var tempNode = bigIndexNode;\n        bigIndexNode = smallIndexNode;\n        smallIndexNode = tempNode;\n    }\n\n    var smallIndexNodeExt = smallIndexNode.getOnCircleNodeExt();\n    var bigIndexNodeExt = bigIndexNode.getOnCircleNodeExt();\n\n    // Calculate the angle for the big index node\n    var smallIndexPrevNode = smallIndexNodeExt.getPrevNode();\n\n    var layout = this.getGraphManager().getLayout();\n    var nodeSeparation = layout.getNodeSeparation();\n\n    var angle = (smallIndexPrevNode.getOnCircleNodeExt().getAngle() + (smallIndexPrevNode.getHalfTheDiagonal() + bigIndexNode.getHalfTheDiagonal() + nodeSeparation) / this.radius) % (2 * Math.PI);\n\n    bigIndexNodeExt.setAngle(angle);\n\n    // Calculate the angle for the small index node\n    angle = (bigIndexNodeExt.getAngle() + (bigIndexNode.getHalfTheDiagonal() + smallIndexNode.getHalfTheDiagonal() + nodeSeparation) / this.radius) % (2 * Math.PI);\n\n    smallIndexNodeExt.setAngle(angle);\n\n    smallIndexNodeExt.updatePosition();\n    bigIndexNodeExt.updatePosition();\n\n    var tempIndex = firstExt.getIndex();\n    firstExt.setIndex(secondExt.getIndex());\n    secondExt.setIndex(tempIndex);\n    this.getOnCircleNodes()[firstExt.getIndex()] = first;\n    this.getOnCircleNodes()[secondExt.getIndex()] = second;\n\n    firstExt.updateSwappingConditions();\n    secondExt.updateSwappingConditions();\n\n    if (firstExt.getNextNode() === second) {\n        firstExt.getPrevNode().getOnCircleNodeExt().updateSwappingConditions();\n        secondExt.getNextNode().getOnCircleNodeExt().updateSwappingConditions();\n    } else {\n        firstExt.getNextNode().getOnCircleNodeExt().updateSwappingConditions();\n        secondExt.getPrevNode().getOnCircleNodeExt().updateSwappingConditions();\n    }\n};\n\n/*\n * This method checks to see for each cluster (in no particular order)\n * whether or not reversing the order of the cluster would reduce\n * inter-cluster edge crossings. The decision is based on global sequence\n * alignment of the order of the nodes in the cluster vs. the order of their\n * neighbors in other clusters. A cluster that was reversed earlier is not\n * reversed again to avoid oscillations. It returns true if reverse order\n * is adapted.\n */\nCiSECircle.prototype.checkAndReverseIfReverseIsBetter = function () {\n    // First form the list of inter cluster edges of this cluster\n    var interClusterEdges = this.getInterClusterEdges();\n    var interClusterEdgeInfos = new Array(interClusterEdges.length);\n\n    // Now form the info array that contains not only the inter-cluster\n    // edges but also other information such as the angle they make w.r.t.\n    // the cluster center and neighboring node center.\n    // In the meantime, calculate how many inter-cluster edge each on-circle\n    // node is incident with. This information will be used to duplicate\n    // char codes of those nodes with 2 or more inter-graph edge.\n    var angle = void 0;\n    var clusterCenter = this.getParent().getCenter();\n    var interClusterEdge = void 0;\n    var endInThisCluster = void 0;\n    var endInOtherCluster = void 0;\n    var centerOfEndInOtherCluster = void 0;\n    var nodeCount = this.onCircleNodes.length;\n    var interClusterEdgeDegree = new Array(nodeCount);\n\n    for (var i = 0; i < nodeCount; i++) {\n        interClusterEdgeDegree[i] = 0;\n    }\n\n    var noOfOnCircleNodesToBeRepeated = 0;\n\n    for (var _i2 = 0; _i2 < interClusterEdges.length; _i2++) {\n        interClusterEdge = interClusterEdges[_i2];\n        endInOtherCluster = this.getOtherEnd(interClusterEdge);\n        centerOfEndInOtherCluster = endInOtherCluster.getCenter();\n        angle = IGeometry.angleOfVector(clusterCenter.x, clusterCenter.y, centerOfEndInOtherCluster.x, centerOfEndInOtherCluster.y);\n        interClusterEdgeInfos[_i2] = new CiSEInterClusterEdgeInfo(interClusterEdge, angle);\n\n        endInThisCluster = this.getThisEnd(interClusterEdge);\n        interClusterEdgeDegree[endInThisCluster.getOnCircleNodeExt().getIndex()]++;\n\n        if (interClusterEdgeDegree[endInThisCluster.getOnCircleNodeExt().getIndex()] > 1) {\n            noOfOnCircleNodesToBeRepeated++;\n        }\n    }\n\n    // On circle nodes will be ordered by their indices in this array\n    var onCircleNodes = this.onCircleNodes;\n\n    // Form arrays for current and reversed order of nodes of this cluster\n    // Take any repetitions into account (if node with char code 'b' is\n    // incident with 3 inter-cluster edges, then repeat 'b' 2 times)\n    var nodeCountWithRepetitions = nodeCount + noOfOnCircleNodesToBeRepeated;\n    var clusterNodes = new Array(2 * nodeCountWithRepetitions);\n    var reversedClusterNodes = new Array(2 * nodeCountWithRepetitions);\n    var node = void 0;\n    var index = -1;\n\n    for (var _i3 = 0; _i3 < nodeCount; _i3++) {\n        node = onCircleNodes[_i3];\n\n        // on circle nodes with no inter-cluster edges are also considered\n        if (interClusterEdgeDegree[_i3] === 0) interClusterEdgeDegree[_i3] = 1;\n\n        for (var j = 0; j < interClusterEdgeDegree[_i3]; j++) {\n            index++;\n\n            clusterNodes[index] = clusterNodes[nodeCountWithRepetitions + index] = reversedClusterNodes[nodeCountWithRepetitions - 1 - index] = reversedClusterNodes[2 * nodeCountWithRepetitions - 1 - index] = node.getOnCircleNodeExt().getCharCode();\n        }\n    }\n\n    // Now sort the inter-cluster edges w.r.t. their angles\n    var edgeSorter = new CiSEInterClusterEdgeSort(this, interClusterEdgeInfos);\n\n    // Form an array for order of neighboring nodes of this cluster\n    var neighborNodes = new Array(interClusterEdgeInfos.length);\n\n    for (var _i4 = 0; _i4 < interClusterEdgeInfos.length; _i4++) {\n        interClusterEdge = interClusterEdgeInfos[_i4].getEdge();\n        endInThisCluster = this.getThisEnd(interClusterEdge);\n        neighborNodes[_i4] = endInThisCluster.getOnCircleNodeExt().getCharCode();\n    }\n\n    // Now calculate a score for the alignment of the current order of the\n    // nodes of this cluster w.r.t. to their neighbors order\n\n    var alignmentScoreCurrent = this.computeAlignmentScore(clusterNodes, neighborNodes);\n\n    // Then calculate a score for the alignment of the reversed order of the\n    // nodes of this cluster w.r.t. to their neighbors order\n\n    if (alignmentScoreCurrent !== -1) {\n        var alignmentScoreReversed = this.computeAlignmentScore(reversedClusterNodes, neighborNodes);\n\n        // Check if reversed order is *substantially* better aligned with\n        // the order of the neighbors of this cluster around the cluster; if\n        // so, reverse the order\n\n        if (alignmentScoreReversed !== -1) {\n            if (alignmentScoreReversed > alignmentScoreCurrent) {\n                this.reverseNodes();\n                this.setMayNotBeReversed();\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * This method computes an alignment for the two input char arrays and\n * returns the alignment amount. If alignment is unsuccessful for some\n * reason, it returns -1.\n */\nCiSECircle.prototype.computeAlignmentScore = function (charArrayReader1, charArrayReader2) {\n    var aligner = new NeedlemanWunsch(charArrayReader1, charArrayReader2, 20, -1, -2);\n    return aligner.getScore();\n};\n\n/**\n * This method reverses the nodes on this circle.\n */\nCiSECircle.prototype.reverseNodes = function () {\n    var onCircleNodes = this.getOnCircleNodes();\n    var noOfNodesOnCircle = this.getOnCircleNodes().length;\n\n    for (var i = 0; i < noOfNodesOnCircle; i++) {\n        var node = onCircleNodes[i];\n        var nodeExt = node.getOnCircleNodeExt();\n\n        nodeExt.setIndex((noOfNodesOnCircle - nodeExt.getIndex()) % noOfNodesOnCircle);\n    }\n\n    this.reCalculateNodeAnglesAndPositions();\n};\n\n/**\n * This method removes given on-circle node from the circle and calls\n * reCalculateCircleSizeAndRadius and  reCalculateNodeAnglesAndPositions.\n * This method should be called when an inner node is found and to be moved\n * inside the circle.\n * @param node\n */\nCiSECircle.prototype.moveOnCircleNodeInside = function (node) {\n\n    // Remove the node from on-circle nodes list and add it to in-circle\n    // nodes list\n    // Make sure it has not been already moved to the out node list\n    var index = this.onCircleNodes.indexOf(node);\n    if (index > -1) {\n        this.onCircleNodes.splice(index, 1);\n    }\n\n    this.inCircleNodes.push(node);\n\n    // Re-adjust all order indexes of remaining on circle nodes.\n    for (var i = 0; i < this.onCircleNodes.length; i++) {\n        var onCircleNode = this.onCircleNodes[i];\n\n        onCircleNode.getOnCircleNodeExt().setIndex(i);\n    }\n\n    // De-register extension\n    node.setAsNonOnCircleNode();\n\n    // calculateRadius\n    this.reCalculateCircleSizeAndRadius();\n\n    //calculateNodePositions\n    this.reCalculateNodeAnglesAndPositions();\n\n    node.setCenter(this.getParent().getCenterX(), this.getParent().getCenterY());\n};\n\n/**\n * This method calculates the size and radius of this circle with respect\n * to the sizes of the vertices and the node separation parameter.\n */\nCiSECircle.prototype.reCalculateCircleSizeAndRadius = function () {\n    var totalDiagonal = 0;\n    var onCircleNodes = this.getOnCircleNodes();\n\n    for (var i = 0; i < onCircleNodes.length; i++) {\n        var node = onCircleNodes[i];\n\n        var temp = node.getWidth() * node.getWidth() + node.getHeight() * node.getHeight();\n        totalDiagonal += Math.sqrt(temp);\n    }\n\n    var layout = this.getGraphManager().getLayout();\n    var nodeSeparation = layout.getNodeSeparation();\n\n    var perimeter = totalDiagonal + this.getOnCircleNodes().length * nodeSeparation;\n    this.radius = perimeter / (2 * Math.PI);\n    this.calculateParentNodeDimension();\n};\n\n/**\n * This method goes over all on-circle nodes and re-calculates their angles\n * and corresponding positions. This method should be called when on-circle\n * nodes (content or order) have been changed for this circle.\n */\nCiSECircle.prototype.reCalculateNodeAnglesAndPositions = function () {\n    var layout = this.getGraphManager().getLayout();\n    var nodeSeparation = layout.getNodeSeparation();\n\n    // It is important that we sort these on-circle nodes in place.\n    var inOrderCopy = this.onCircleNodes;\n    inOrderCopy.sort(function (a, b) {\n        return a.getOnCircleNodeExt().getIndex() - b.getOnCircleNodeExt().getIndex();\n    });\n\n    var parentCenterX = this.getParent().getCenterX();\n    var parentCenterY = this.getParent().getCenterY();\n\n    for (var i = 0; i < inOrderCopy.length; i++) {\n        var node = inOrderCopy[i];\n        var angle = void 0;\n\n        if (i === 0) {\n            angle = 0.0;\n        } else {\n            var previousNode = inOrderCopy[i - 1];\n\n            // => angle in radian = (2*PI)*(circular distance/(2*PI*r))\n            angle = previousNode.getOnCircleNodeExt().getAngle() + (node.getHalfTheDiagonal() + nodeSeparation + previousNode.getHalfTheDiagonal()) / this.radius;\n        }\n\n        node.getOnCircleNodeExt().setAngle(angle);\n        node.setCenter(parentCenterX + this.radius * Math.cos(angle), parentCenterY + this.radius * Math.sin(angle));\n    }\n};\n\nmodule.exports = CiSECircle;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class implements data and functionality required for CiSE layout per\n * edge.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar FDLayoutEdge = __webpack_require__(0).layoutBase.FDLayoutEdge;\n\n// -----------------------------------------------------------------------------\n// Section: Constructors and initialization\n// -----------------------------------------------------------------------------\n\n// Constructor\nfunction CiSEEdge(source, target, vEdge) {\n    FDLayoutEdge.call(this, source, target, vEdge);\n\n    /**\n     * Flag for inter-graph edges in the base is not good enough. So we define\n     * this one to mean: a CiSE edge is intra-cluster only if both its ends are\n     * on a common circle; not intra-cluster, otherwise!\n     */\n    this.isIntraCluster = true;\n}\n\nCiSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\n\nfor (var property in FDLayoutEdge) {\n    CiSEEdge[property] = FDLayoutEdge[property];\n}\n\nCiSEEdge.prototype.isIntraEdge = function () {\n    return this.isIntraCluster;\n};\n\n// -----------------------------------------------------------------------------\n// Section: Remaining methods\n// -----------------------------------------------------------------------------\n\n/**\n * This method checks whether this edge crosses with the input edge. It\n * returns false, if any of the vertices those edges are incident to are\n * not yet placed on the circle.\n */\nCiSEEdge.prototype.crossesWithEdge = function (other) {\n    var result = false;\n    var sourceExt = this.getSource().getOnCircleNodeExt();\n    var targetExt = this.getTarget().getOnCircleNodeExt();\n    var otherSourceExt = other.getSource().getOnCircleNodeExt();\n    var otherTargetExt = other.getTarget().getOnCircleNodeExt();\n    var sourcePos = -1;\n    var targetPos = -1;\n    var otherSourcePos = -1;\n    var otherTargetPos = -1;\n\n    if (sourceExt !== null) sourcePos = sourceExt.getIndex();\n\n    if (targetExt !== null) targetPos = targetExt.getIndex();\n\n    if (otherSourceExt !== null) otherSourcePos = otherSourceExt.getIndex();\n\n    if (otherTargetExt !== null) otherTargetPos = otherTargetExt.getIndex();\n\n    if (!this.isInterGraph && !other.isInterGraph) {\n        if (this.source.getOwner() !== this.target.getOwner()) result = false;else {\n            // if any of the vertices those two edges are not yet placed\n            if (sourcePos === -1 || targetPos === -1 || otherSourcePos === -1 || otherTargetPos === -1) result = false;\n\n            var otherSourceDist = otherSourceExt.getCircDistWithTheNode(sourceExt);\n            var otherTargetDist = otherTargetExt.getCircDistWithTheNode(sourceExt);\n            var thisTargetDist = targetExt.getCircDistWithTheNode(sourceExt);\n\n            if (thisTargetDist < Math.max(otherSourceDist, otherTargetDist) && thisTargetDist > Math.min(otherSourceDist, otherTargetDist) && otherTargetDist !== 0 && otherSourceDist !== 0) {\n                result = true;\n            }\n        }\n    } else {\n        result = true;\n    }\n\n    return result;\n};\n\n/**\n * This method calculates the total number of crossings of this edge with\n * all the edges given in the input list.\n */\nCiSEEdge.prototype.calculateTotalCrossingWithList = function (edgeList) {\n    var totalCrossing = 0;\n    for (var i = 0; i < edgeList.length; i++) {\n        totalCrossing += this.crossingWithEdge(edgeList[i]);\n    }return totalCrossing;\n};\n\n/**\n * This method returns 1 if this edge crosses with the input edge, 0\n * otherwise.\n */\nCiSEEdge.prototype.crossingWithEdge = function (other) {\n    var crosses = this.crossesWithEdge(other);\n    var result = 0;\n\n    if (crosses) result = 1;\n\n    return result;\n};\n\nmodule.exports = CiSEEdge;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class implements a graph-manager for CiSE layout specific data and\n * functionality.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LGraphManager = __webpack_require__(0).layoutBase.LGraphManager;\n\n// -----------------------------------------------------------------------------\n// Section: Constructors and initialization\n// -----------------------------------------------------------------------------\n\nfunction CiSEGraphManager(layout) {\n    LGraphManager.call(this, layout);\n\n    /**\n     * All on-circle and other nodes (unclustered nodes and nodes representing\n     * each cluster/circle) in this graph manager. For efficiency purposes we\n     * hold references of these nodes that we operate on in arrays.\n     */\n\n    this.onCircleNodes = [];\n    this.inCircleNodes = [];\n    this.nonOnCircleNodes = [];\n}\n\nCiSEGraphManager.prototype = Object.create(LGraphManager.prototype);\n\nfor (var property in LGraphManager) {\n    CiSEGraphManager[property] = LGraphManager[property];\n}\n\n// -----------------------------------------------------------------------------\n// Section: Accessors\n// -----------------------------------------------------------------------------\n\n// This method returns an array of all on-circle nodes.\nCiSEGraphManager.prototype.getOnCircleNodes = function () {\n    return this.onCircleNodes;\n};\n\n// This method returns an array of all in-circle nodes.\nCiSEGraphManager.prototype.getInCircleNodes = function () {\n    return this.inCircleNodes;\n};\n\n// This method returns an array of all nodes other than on-circle nodes.\nCiSEGraphManager.prototype.getNonOnCircleNodes = function () {\n    return this.nonOnCircleNodes;\n};\n\n// This method sets the array of all on-circle nodes.\nCiSEGraphManager.prototype.setOnCircleNodes = function (nodes) {\n    this.onCircleNodes = nodes;\n};\n\n// This method sets the array of all in-circle nodes.\nCiSEGraphManager.prototype.setInCircleNodes = function (nodes) {\n    this.inCircleNodes = nodes;\n};\n\n// This method sets the array of all nodes other than on-circle nodes.\nCiSEGraphManager.prototype.setNonOnCircleNodes = function (nodes) {\n    this.nonOnCircleNodes = nodes;\n};\n\nmodule.exports = CiSEGraphManager;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class keeps the information of each inter-cluster edge of the associated\n * circle. It is to be used for sorting inter-cluster edges based on this info.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nfunction CiSEInterClusterEdgeInfo(edge, angle) {\n    // Inter-cluster edge\n    this.edge = edge;\n\n    // Angle in radians (in clockwise direction from the positive x-axis) that\n    // is computed for this inter-cluster edge based on the line segment with\n    // one end as the center of the associated cluster and the other end being\n    // the center of the source/target node of this inter-cluster edge that is\n    // not in this cluster.\n    this.angle = angle;\n}\n\nCiSEInterClusterEdgeInfo.prototype = Object.create(null);\n\nCiSEInterClusterEdgeInfo.prototype.getEdge = function () {\n    return this.edge;\n};\n\nCiSEInterClusterEdgeInfo.prototype.getAngle = function () {\n    return this.angle;\n};\n\nmodule.exports = CiSEInterClusterEdgeInfo;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * This class sorts the array of input edges based on the associated angles. If\n * angles turn out to be the same, then we sort the edges based on their\n * in-cluster end nodes' orders in clockwise direction. This information is\n * calculated beforehand and stored in a matrix in each associated circle.\n *\n */\n\nvar CiSEInterClusterEdgeSort = function () {\n    function CiSEInterClusterEdgeSort(ownerCircle, A) {\n        _classCallCheck(this, CiSEInterClusterEdgeSort);\n\n        this.ownerCircle = ownerCircle;\n        this._quicksort(A, 0, A.length - 1);\n    }\n\n    _createClass(CiSEInterClusterEdgeSort, [{\n        key: \"compareFunction\",\n        value: function compareFunction(a, b) {\n            if (b.getAngle() > a.getAngle()) return true;else if (b.getAngle() === a.getAngle()) {\n                if (a === b) {\n                    return false;\n                } else {\n                    return this.ownerCircle.getOrder(this.ownerCircle.getThisEnd(a.getEdge()), this.ownerCircle.getThisEnd(b.getEdge()));\n                }\n            } else {\n                return false;\n            }\n        }\n    }, {\n        key: \"_quicksort\",\n        value: function _quicksort(A, p, r) {\n            if (p < r) {\n                var q = this._partition(A, p, r);\n                this._quicksort(A, p, q);\n                this._quicksort(A, q + 1, r);\n            }\n        }\n    }, {\n        key: \"_partition\",\n        value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n            var i = p;\n            var j = r;\n            while (true) {\n                while (this.compareFunction(x, this._get(A, j))) {\n                    j--;\n                }while (this.compareFunction(this._get(A, i), x)) {\n                    i++;\n                }if (i < j) {\n                    this._swap(A, i, j);\n                    i++;\n                    j--;\n                } else return j;\n            }\n        }\n    }, {\n        key: \"_get\",\n        value: function _get(object, index) {\n            return object[index];\n        }\n    }, {\n        key: \"_set\",\n        value: function _set(object, index, value) {\n            object[index] = value;\n        }\n    }, {\n        key: \"_swap\",\n        value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n            this._set(A, i, this._get(A, j));\n            this._set(A, j, temp);\n        }\n    }]);\n\n    return CiSEInterClusterEdgeSort;\n}();\n\nmodule.exports = CiSEInterClusterEdgeSort;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class implements a Circular Spring Embedder (CiSE) layout algortithm.\n * The algorithm is used for layout of clustered nodes where nodes in each\n * cluster is drawn around a circle. The basic steps of the algorithm follows:\n * - Step 1: each cluster is laid out with AVSDF circular layout algorithm;\n * - Step 2: cluster graph (quotient graph of the clustered graph, where nodes\n *   correspond to clusters and edges correspond to inter-cluster edges) is laid\n *   out with a spring embedder to determine the initial layout;\n * - Steps 3-5: the cluster graph is laid out with a modified spring embedder,\n *   where the nodes corresponding to clusters are also allowed to rotate,\n *   indirectly affecting the layout of the nodes inside the clusters. In Step\n *   3, we allow flipping of clusters, whereas in Step 4, we allow swapping of\n *   neighboring node pairs in a cluster to improve inter-cluster edge crossings\n *   without increasing intra-cluster crossings.\n *\n *   The input view aspect of GraphManager is inherited from Java version of\n *   CiSE (Chilay) as a side effect. Ignore any references to 'view' elements.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\n// -----------------------------------------------------------------------------\n// Section: Initializations\n// -----------------------------------------------------------------------------\n\nvar Layout = __webpack_require__(0).layoutBase.FDLayout;\nvar HashMap = __webpack_require__(0).layoutBase.HashMap;\nvar PointD = __webpack_require__(0).layoutBase.PointD;\nvar DimensionD = __webpack_require__(0).layoutBase.DimensionD;\nvar AVSDFConstants = __webpack_require__(0).AVSDFConstants;\nvar AVSDFLayout = __webpack_require__(0).AVSDFLayout;\nvar CoSELayout = __webpack_require__(3).CoSELayout;\nvar CoSEConstants = __webpack_require__(3).CoSEConstants;\nvar CiSEConstants = __webpack_require__(1);\nvar CiSEGraphManager = __webpack_require__(7);\nvar CiSECircle = __webpack_require__(5);\nvar CiSENode = __webpack_require__(11);\nvar CiSEEdge = __webpack_require__(6);\nvar CiSEOnCircleNodePair = __webpack_require__(13);\n\n// Constructor\nfunction CiSELayout() {\n    Layout.call(this);\n\n    /**\n     * Whether it is incremental\n     */\n    this.incremental = CiSEConstants.INCREMENTAL;\n\n    /**\n     * Separation of the nodes on each circle customizable by the user\n     */\n    this.nodeSeparation = CiSEConstants.DEFAULT_NODE_SEPARATION;\n\n    /**\n     * Ideal edge length coefficient for inter-cluster edges\n     */\n    this.idealInterClusterEdgeLengthCoefficient = CiSEConstants.DEFAULT_IDEAL_INTER_CLUSTER_EDGE_LENGTH_COEFF;\n\n    /**\n     * Decides whether pull on-circle nodes inside of the circle.\n     */\n    this.allowNodesInsideCircle = CiSEConstants.DEFAULT_ALLOW_NODES_INSIDE_CIRCLE;\n\n    /**\n     * Max percentage of the nodes in a circle that can move inside the circle\n     */\n    this.maxRatioOfNodesInsideCircle = CiSEConstants.DEFAULT_MAX_RATIO_OF_NODES_INSIDE_CIRCLE;\n\n    /**\n     * Current step of the layout process\n     */\n    this.step = CiSELayout.STEP_NOT_STARTED;\n\n    /**\n     * Current phase of current step\n     */\n    this.phase = CiSELayout.PHASE_NOT_STARTED;\n\n    /**\n     * Holds the set of pairs swapped in the last swap phase.\n     */\n    this.swappedPairsInLastIteration = [];\n\n    /**\n     * Iterations in the runSpringEmbedderTicl function\n     */\n    this.iterations = 0;\n\n    this.oldTotalDisplacement = 0.0;\n\n    /**\n     * Cooling Factor Variables\n     */\n    this.coolingCycle = 0;\n    this.maxCoolingCycle = this.maxIterations / CiSEConstants.CONVERGENCE_CHECK_PERIOD;\n}\n\nCiSELayout.prototype = Object.create(Layout.prototype);\n\nfor (var property in Layout) {\n    CiSELayout[property] = Layout[property];\n}\n\n// -----------------------------------------------------------------------------\n// Section: Class constants\n// -----------------------------------------------------------------------------\n/**\n * Steps of layout\n */\nCiSELayout.STEP_NOT_STARTED = 0;\nCiSELayout.STEP_1 = 1;\nCiSELayout.STEP_2 = 2;\nCiSELayout.STEP_3 = 3;\nCiSELayout.STEP_4 = 4;\nCiSELayout.STEP_5 = 5;\n\n/**\n * Phases of a step\n */\nCiSELayout.PHASE_NOT_STARTED = 0;\nCiSELayout.PHASE_SWAP_PREPERATION = 1;\nCiSELayout.PHASE_PERFORM_SWAP = 2;\nCiSELayout.PHASE_OTHER = 3;\n\n// -----------------------------------------------------------------------------\n// Section: Class methods\n// -----------------------------------------------------------------------------\n\n/**\n * This method creates a new graph manager associated with this layout.\n */\nCiSELayout.prototype.newGraphManager = function () {\n    this.graphManager = new CiSEGraphManager(this);\n    return this.graphManager;\n};\n\n/**\n * This method creates a new graph(CiSECircle) associated with the input view graph.\n */\nCiSELayout.prototype.newCircleLGraph = function (vGraph) {\n    return new CiSECircle(null, this.graphManager, vGraph);\n};\n\n/**\n * This method creates a new node associated with the input view node.\n */\nCiSELayout.prototype.newNode = function (loc, size) {\n    return new CiSENode(this.graphManager, loc, size, null);\n};\n\n/**\n * This method creates a new on-circle CiSE node associated with the input\n * view node.\n */\nCiSELayout.prototype.newCiSEOnCircleNode = function (loc, size) {\n    var newNode = this.newNode(loc, size);\n    newNode.setAsOnCircleNode();\n\n    return newNode;\n};\n\n/**\n * This method creates a new edge associated with the input view edge.\n */\nCiSELayout.prototype.newEdge = function (source, target, vEdge) {\n    return new CiSEEdge(source, target, vEdge);\n};\n\n/**\n * This method returns the node separation amount for this layout.\n */\nCiSELayout.prototype.getNodeSeparation = function () {\n    return this.nodeSeparation;\n};\n\n/**\n * This method establishes the GraphManager object related to this layout. Each compound(LGraph) is CiSECircle except\n * for the root.\n * @param nodes: All nodes in the graph\n * @param edges: All edges in the graph\n * @param clusters: Array of cluster ID arrays. Each array represents a cluster where ID ∈ {0,1,2,..,n(# of clusters)}\n *\n * Notes:\n * -> For unclustered nodes, their clusterID is -1.\n * -> CiSENode that corresponds to a cluster has no ID property.\n */\nCiSELayout.prototype.convertToClusteredGraph = function (nodes, edges, clusters) {\n    var _this = this;\n\n    var self = this;\n    var idToLNode = {};\n    var rootGraph = this.graphManager.getRoot();\n\n    // Firstly, lets create a HashMap to get node properties easier\n    var idToCytoscapeNode = new HashMap();\n    for (var i = 0; i < nodes.length; i++) {\n        idToCytoscapeNode.put(nodes[i].data('id'), nodes[i]);\n    }\n\n    // If it is a function just change it\n    if (typeof clusters === \"function\") {\n        var cIDs = [];\n        var temp = [];\n\n        for (var _i = 0; _i < nodes.length; _i++) {\n            var cID = clusters(nodes[_i]);\n            if (cID > 0 && cID !== null && cID !== undefined) {\n                var index = cIDs.indexOf(cID);\n                if (index > -1) {\n                    temp[index].push(nodes[_i].data('id'));\n                } else {\n                    cIDs.push(cID);\n                    temp.push([nodes[_i].data('id')]);\n                }\n            }\n        }\n        clusters = temp;\n    }\n\n    // lets add the nodes in clusters to the GraphManager\n\n    var _loop = function _loop(_i2) {\n        if (clusters[_i2].length === 0) return 'continue';\n\n        // Create a CiSENode for the cluster\n        var clusterNode = _this.newNode(null);\n\n        // ClusterID ∈ {0,1,2,..,n(# of clusters)}\n        clusterNode.setClusterId(_i2);\n\n        // Add it rootGraph\n        rootGraph.add(clusterNode);\n\n        // Create the associated Circle representing the cluster and link them together\n        var circle = _this.newCircleLGraph(null);\n        _this.graphManager.add(circle, clusterNode);\n\n        // Set bigger margins so clusters are spaced out nicely\n        circle.margin = circle.margin + 15;\n\n        // Move each node of the cluster into this circle\n        clusters[_i2].forEach(function (nodeID) {\n            var cytoNode = idToCytoscapeNode.get(nodeID);\n            var dimensions = cytoNode.layoutDimensions({\n                nodeDimensionsIncludeLabels: false\n            });\n            // Adding a node into the circle\n            var ciseNode = self.newCiSEOnCircleNode(new PointD(cytoNode.position('x') - dimensions.w / 2, cytoNode.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h)));\n            ciseNode.setId(nodeID);\n            ciseNode.setClusterId(_i2);\n            circle.getOnCircleNodes().push(ciseNode);\n            circle.add(ciseNode);\n\n            // Initially all on-circle nodes are assumed to be in-nodes\n            circle.getInNodes().push(ciseNode);\n\n            // Map the node\n            idToLNode[ciseNode.getId()] = ciseNode;\n        });\n    };\n\n    for (var _i2 = 0; _i2 < clusters.length; _i2++) {\n        var _ret = _loop(_i2);\n\n        if (_ret === 'continue') continue;\n    }\n\n    // Now, add unclustered nodes to the GraphManager\n\n    var _loop2 = function _loop2(_i3) {\n        var clustered = false;\n\n        clusters.forEach(function (cluster) {\n            if (cluster.includes(nodes[_i3].data('id'))) clustered = true;\n        });\n\n        if (!clustered) {\n            var cytoNode = nodes[_i3];\n            var dimensions = cytoNode.layoutDimensions({\n                nodeDimensionsIncludeLabels: false\n            });\n            var _CiSENode = _this.newNode(new PointD(cytoNode.position('x') - dimensions.w / 2, cytoNode.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h)));\n            _CiSENode.setClusterId(-1);\n            _CiSENode.setId(nodes[_i3].data('id'));\n            rootGraph.add(_CiSENode);\n\n            // Map the node\n            idToLNode[_CiSENode.getId()] = _CiSENode;\n        }\n    };\n\n    for (var _i3 = 0; _i3 < nodes.length; _i3++) {\n        _loop2(_i3);\n    }\n\n    // Lastly, add all edges\n    for (var _i4 = 0; _i4 < edges.length; _i4++) {\n        var e = edges[_i4];\n        var sourceNode = idToLNode[e.data(\"source\")];\n        var targetNode = idToLNode[e.data(\"target\")];\n        var sourceClusterID = sourceNode.getClusterId();\n        var targetClusterID = targetNode.getClusterId();\n\n        if (sourceNode === targetNode) continue;\n\n        var ciseEdge = self.newEdge(sourceNode, targetNode, null);\n\n        // Edge is intracluster\n        // Remember: If source or target is unclustered then edge is Not intracluster\n        if (sourceClusterID === targetClusterID && sourceClusterID !== -1 && targetClusterID !== -1) {\n            ciseEdge.isIntraCluster = true;\n            ciseEdge.getSource().getOwner().add(ciseEdge, ciseEdge.getSource(), ciseEdge.getTarget());\n        } else {\n            ciseEdge.isIntraCluster = false;\n            this.graphManager.add(ciseEdge, ciseEdge.getSource(), ciseEdge.getTarget());\n        }\n    }\n\n    // Populate the references of GraphManager\n    var onCircleNodes = [];\n    var nonOnCircleNodes = [];\n    var allNodes = this.graphManager.getAllNodes();\n    for (var _i5 = 0; _i5 < allNodes.length; _i5++) {\n        if (allNodes[_i5].getOnCircleNodeExt()) {\n            onCircleNodes.push(allNodes[_i5]);\n        } else {\n            nonOnCircleNodes.push(allNodes[_i5]);\n        }\n    }\n\n    this.graphManager.setOnCircleNodes(onCircleNodes);\n    this.graphManager.setNonOnCircleNodes(nonOnCircleNodes);\n\n    // Deternine out-nodes of each circle\n    this.graphManager.edges.forEach(function (e) {\n        var sourceNode = e.getSource();\n        var targetNode = e.getTarget();\n        var sourceClusterID = sourceNode.getClusterId();\n        var targetClusterID = targetNode.getClusterId();\n\n        // If an on-circle node is an out-node, then remove it from the\n        // in-node list and add it to out-node list of the associated\n        // circle. Notice that one or two ends of an inter-graph edge will\n        // be out-node(s).\n        if (sourceClusterID !== -1) {\n            var _circle = sourceNode.getOwner();\n\n            // Make sure it has not been already moved to the out node list\n            var _index = _circle.getInNodes().indexOf(sourceNode);\n            if (_index > -1) {\n                _circle.getInNodes().splice(_index, 1);\n                _circle.getOutNodes().push(sourceNode);\n            }\n        }\n\n        if (targetClusterID !== -1) {\n            var _circle2 = targetNode.getOwner();\n\n            // Make sure it has not been already moved to the out node list\n            var _index2 = _circle2.getInNodes().indexOf(targetNode);\n            if (_index2 > -1) {\n                _circle2.getInNodes().splice(_index2, 1);\n                _circle2.getOutNodes().push(targetNode);\n            }\n        }\n    });\n\n    return idToLNode;\n};\n\n/**\n * This method runs AVSDF layout for each cluster.\n */\nCiSELayout.prototype.doStep1 = function () {\n    this.step = CiSELayout.STEP_1;\n    this.phase = CiSELayout.PHASE_OTHER;\n\n    // Mapping for transferring positions and dimensions back\n    var ciseToAvsdf = new HashMap();\n\n    var allGraphs = this.graphManager.getGraphs();\n    for (var i = 0; i < allGraphs.length; i++) {\n        var graph = allGraphs[i];\n\n        // Skip the root graph which is a normal LGraph\n        if (graph instanceof CiSECircle) {\n            // Create the AVSDF layout objects\n            AVSDFConstants.DEFAULT_NODE_SEPARATION = this.nodeSeparation;\n            var avsdfLayout = new AVSDFLayout();\n            var avsdfCircle = avsdfLayout.graphManager.addRoot();\n            var clusteredNodes = graph.getOnCircleNodes();\n\n            // Create corresponding AVSDF nodes in current cluster\n            for (var _i6 = 0; _i6 < clusteredNodes.length; _i6++) {\n                var ciseOnCircleNode = clusteredNodes[_i6];\n\n                var avsdfNode = avsdfLayout.newNode(null);\n                var loc = ciseOnCircleNode.getLocation();\n                avsdfNode.setLocation(loc.x, loc.y);\n                avsdfNode.setWidth(ciseOnCircleNode.getWidth());\n                avsdfNode.setHeight(ciseOnCircleNode.getHeight());\n                avsdfCircle.add(avsdfNode);\n\n                ciseToAvsdf.put(ciseOnCircleNode, avsdfNode);\n            }\n\n            // For each edge, create a corresponding AVSDF edge if its both ends\n            // are in this cluster.\n            var allEdges = this.getAllEdges();\n            for (var _i7 = 0; _i7 < allEdges.length; _i7++) {\n                var edge = allEdges[_i7];\n\n                if (clusteredNodes.includes(edge.getSource()) && clusteredNodes.includes(edge.getTarget())) {\n                    var avsdfSource = ciseToAvsdf.get(edge.getSource());\n                    var avsdfTarget = ciseToAvsdf.get(edge.getTarget());\n                    var avsdfEdge = avsdfLayout.newEdge(\"\");\n\n                    avsdfCircle.add(avsdfEdge, avsdfSource, avsdfTarget);\n                }\n            }\n\n            // Run AVSDF layout\n            avsdfLayout.layout();\n\n            // Do post-processing\n            var sortedByDegreeList = avsdfLayout.initPostProcess();\n            for (var _i8 = 0; _i8 < sortedByDegreeList.length; _i8++) {\n                avsdfLayout.oneStepPostProcess(sortedByDegreeList[_i8]);\n            }\n            avsdfLayout.updateNodeAngles();\n            avsdfLayout.updateNodeCoordinates();\n\n            // Reflect changes back to CiSENode's\n            for (var _i9 = 0; _i9 < clusteredNodes.length; _i9++) {\n                var _ciseOnCircleNode = clusteredNodes[_i9];\n                var _avsdfNode = ciseToAvsdf.get(_ciseOnCircleNode);\n                var _loc = _avsdfNode.getLocation();\n                _ciseOnCircleNode.setLocation(_loc.x, _loc.y);\n                _ciseOnCircleNode.getOnCircleNodeExt().setIndex(_avsdfNode.getIndex());\n                _ciseOnCircleNode.getOnCircleNodeExt().setAngle(_avsdfNode.getAngle());\n            }\n\n            // Sort nodes of this ciseCircle according to circle indexes of\n            // ciseOnCircleNodes.\n            clusteredNodes.sort(function (a, b) {\n                return a.getOnCircleNodeExt().getIndex() - b.getOnCircleNodeExt().getIndex();\n            });\n\n            // Assign width and height of the AVSDF circle containing the nodes\n            // above to the corresponding cise-circle.\n            if (avsdfCircle.getNodes().length > 0) {\n                var parentCiSE = graph.getParent();\n                var parentAVSDF = avsdfCircle.getParent();\n                parentCiSE.setLocation(parentAVSDF.getLocation().x, parentAVSDF.getLocation().y);\n                graph.setRadius(avsdfCircle.getRadius());\n                graph.calculateParentNodeDimension();\n            }\n        }\n    }\n};\n\n/**\n * This method runs a spring embedder on the cluster-graph (quotient graph\n * of the clustered graph) to determine initial layout.\n */\nCiSELayout.prototype.doStep2 = function () {\n    this.step = CiSELayout.STEP_2;\n    this.phase = CiSELayout.PHASE_OTHER;\n    var newCoSENodes = [];\n    var newCoSEEdges = [];\n\n    // Used for holding conversion mapping between cise and cose nodes.\n    var ciseNodeToCoseNode = new HashMap();\n\n    // Used for reverse mapping between cose and cise edges while sorting\n    // incident edges.\n    var coseEdgeToCiseEdges = new HashMap();\n\n    // Create a CoSE layout object\n    var coseLayout = new CoSELayout();\n    coseLayout.isSubLayout = false;\n    coseLayout.useMultiLevelScaling = false;\n    coseLayout.useFRGridVariant = true;\n    coseLayout.springConstant *= 1.5;\n\n    var gm = coseLayout.newGraphManager();\n    var coseRoot = gm.addRoot();\n\n    // Traverse through all nodes and create new CoSENode's.\n    // !WARNING! = REMEMBER to set unique \"id\" properties to CoSENodes!!!!\n    var nonOnCircleNodes = this.graphManager.getNonOnCircleNodes();\n    for (var i = 0; i < nonOnCircleNodes.length; i++) {\n        var ciseNode = nonOnCircleNodes[i];\n\n        var newNode = coseLayout.newNode(null);\n        var loc = ciseNode.getLocation();\n        newNode.setLocation(loc.x, loc.y);\n        newNode.setWidth(ciseNode.getWidth());\n        newNode.setHeight(ciseNode.getHeight());\n\n        // Set nodes corresponding to circles to be larger than original, so\n        // inter-cluster edges end up longer.\n        if (ciseNode.getChild() != null) {\n            newNode.setWidth(1.2 * newNode.getWidth());\n            newNode.setHeight(1.2 * newNode.getHeight());\n        }\n\n        // !WARNING! = CoSE EXPECTS \"id\" PROPERTY IMPLICITLY, REMOVING IT WILL CAUSE TILING TO OCCUR ON THE WHOLE GRAPH\n        newNode.id = i;\n\n        coseRoot.add(newNode);\n        newCoSENodes.push(newNode);\n        ciseNodeToCoseNode.put(ciseNode, newNode);\n    }\n\n    // Used for preventing duplicate edge creation between two cose nodes\n    var nodePairs = new Array(newCoSENodes.length);\n    for (var _i10 = 0; _i10 < nodePairs.length; _i10++) {\n        nodePairs[_i10] = new Array(newCoSENodes.length);\n    }\n\n    // Traverse through edges and create cose edges for inter-cluster ones.\n    var allEdges = this.graphManager.getAllEdges();\n    for (var _i11 = 0; _i11 < allEdges.length; _i11++) {\n        var ciseEdge = allEdges[_i11];\n        var sourceCise = ciseEdge.getSource();\n        var targetCise = ciseEdge.getTarget();\n\n        // Determine source and target nodes for current edge\n        if (sourceCise.getOnCircleNodeExt() != null) {\n            // Source node is an on-circle node, take its parent as source node\n            sourceCise = ciseEdge.getSource().getOwner().getParent();\n        }\n        if (targetCise.getOnCircleNodeExt() != null) {\n            // Target node is an on-circle node, take its parent as target node\n            targetCise = ciseEdge.getTarget().getOwner().getParent();\n        }\n\n        var sourceCose = ciseNodeToCoseNode.get(sourceCise);\n        var targetCose = ciseNodeToCoseNode.get(targetCise);\n        var sourceIndex = newCoSENodes.indexOf(sourceCose);\n        var targetIndex = newCoSENodes.indexOf(targetCose);\n\n        var newEdge = void 0;\n        if (sourceIndex !== targetIndex) {\n            // Make sure it's an inter-cluster edge\n\n            if (nodePairs[sourceIndex][targetIndex] == null && nodePairs[targetIndex][sourceIndex] == null) {\n                newEdge = coseLayout.newEdge(null);\n                coseRoot.add(newEdge, sourceCose, targetCose);\n                newCoSEEdges.push(newEdge);\n\n                coseEdgeToCiseEdges.put(newEdge, []);\n\n                nodePairs[sourceIndex][targetIndex] = newEdge;\n                nodePairs[targetIndex][sourceIndex] = newEdge;\n            } else {\n                newEdge = nodePairs[sourceIndex][targetIndex];\n            }\n\n            coseEdgeToCiseEdges.get(newEdge).push(ciseEdge);\n        }\n    }\n\n    // Run CoSELayout\n    coseLayout.runLayout();\n\n    // Reflect changes back to cise nodes\n    // First update all non-on-circle nodes.\n    for (var _i12 = 0; _i12 < nonOnCircleNodes.length; _i12++) {\n        var _ciseNode = nonOnCircleNodes[_i12];\n        var coseNode = ciseNodeToCoseNode.get(_ciseNode);\n        var _loc2 = coseNode.getLocation();\n        _ciseNode.setLocation(_loc2.x, _loc2.y);\n    }\n\n    // Then update all cise on-circle nodes, since their parents have\n    // changed location.\n\n    var onCircleNodes = this.graphManager.getOnCircleNodes();\n\n    for (var _i13 = 0; _i13 < onCircleNodes.length; _i13++) {\n        var _ciseNode2 = onCircleNodes[_i13];\n        var _loc3 = _ciseNode2.getLocation();\n        var parentLoc = _ciseNode2.getOwner().getParent().getLocation();\n        _ciseNode2.setLocation(_loc3.x + parentLoc.x, _loc3.y + parentLoc.y);\n    }\n};\n\n/**\n * This method runs a modified spring embedder as described by the CiSE\n * layout algorithm where the on-circle nodes are fixed (pinned down to\n * the location on their owner circle). Circles, however, are allowed to be\n * flipped (i.e. nodes are re-ordered in the reverse direction) if reversal\n * yields a better aligned neighborhood (w.r.t. its inter-graph edges).\n */\nCiSELayout.prototype.step3Init = function () {\n    this.step = CiSELayout.STEP_3;\n    this.phase = CiSELayout.PHASE_OTHER;\n    this.initSpringEmbedder();\n    this.coolingCycle = 0;\n};\n\n/**\n * This method runs a modified spring embedder as described by the CiSE\n * layout algorithm where the neighboring on-circle nodes are allowed to\n * move by swapping without increasing crossing number but circles are not\n * allowed to be flipped.\n */\nCiSELayout.prototype.step4Init = function () {\n    this.step = CiSELayout.STEP_4;\n    this.phase = CiSELayout.PHASE_OTHER;\n    this.initSpringEmbedder();\n    for (var i = 0; i < this.graphManager.getOnCircleNodes().length; i++) {\n        this.graphManager.getOnCircleNodes()[i].getOnCircleNodeExt().updateSwappingConditions();\n    }\n    this.coolingCycle = 0;\n};\n\n/**\n * This method runs a modified spring embedder as described by the CiSE\n * layout algorithm where the on-circle nodes are fixed (pinned down to\n * the location on their owner circle) and circles are not allowed to be\n * flipped.\n */\nCiSELayout.prototype.step5Init = function () {\n    this.step = CiSELayout.STEP_5;\n    this.phase = CiSELayout.PHASE_OTHER;\n    this.initSpringEmbedder();\n    this.coolingCycle = 0;\n};\n\n/**\n * This method implements a spring embedder used by steps 3 thru 5 with\n * potentially different parameters.\n *\n */\nCiSELayout.prototype.runSpringEmbedderTick = function () {\n    // This function uses iterations but FDLayout uses this.totalIterations\n    this.iterations++;\n    this.totalIterations = this.iterations;\n\n    if (this.iterations % CiSEConstants.CONVERGENCE_CHECK_PERIOD === 0) {\n        // In step 4 make sure at least a 1/4 of max iters take place\n        var notTooEarly = this.step !== CiSELayout.STEP_4 || this.iterations > this.maxIterations / 4;\n\n        if (notTooEarly && this.isConverged()) {\n            return true;\n        }\n\n        // Cooling factor descend function\n        //this.coolingFactor = this.initialCoolingFactor * Math.pow( 1 - 0.005 , this.iterations) ;\n\n        this.coolingFactor = this.initialCoolingFactor * ((this.maxIterations - this.iterations) / this.maxIterations);\n    }\n\n    this.totalDisplacement = 0;\n\n    if (this.step === CiSELayout.STEP_3) {\n        if (this.iterations % CiSEConstants.REVERSE_PERIOD === 0) {\n            this.checkAndReverseIfReverseIsBetter();\n        }\n    } else if (this.step === CiSELayout.STEP_4) {\n        // clear history every now and then\n        if (this.iterations % CiSEConstants.SWAP_HISTORY_CLEARANCE_PERIOD === 0) {\n            this.swappedPairsInLastIteration = [];\n        }\n\n        // no of iterations in this swap period\n        var iterationInPeriod = this.iterations % CiSEConstants.SWAP_PERIOD;\n\n        if (iterationInPeriod >= CiSEConstants.SWAP_IDLE_DURATION) {\n            this.phase = CiSELayout.PHASE_SWAP_PREPERATION;\n        } else if (iterationInPeriod === 0) {\n            this.phase = CiSELayout.PHASE_PERFORM_SWAP;\n        } else {\n            this.phase = CiSELayout.PHASE_OTHER;\n        }\n    }\n\n    this.calcSpringForces();\n    this.calcRepulsionForces();\n    this.calcGravitationalForces();\n    this.calcTotalForces();\n    this.moveNodes();\n\n    return this.iterations >= this.maxIterations;\n};\n\n/**\n * This method prepares circles for possible reversal by computing the order\n * matrix of each circle. It also determines any circles that should never\n * be reversed (e.g. when it has no more than 1 inter-cluster edge).\n */\n\nCiSELayout.prototype.prepareCirclesForReversal = function () {\n    var nodes = this.graphManager.getRoot().getNodes();\n    nodes.forEach(function (node) {\n        var circle = node.getChild();\n        if (circle !== null && circle !== undefined) {\n            //It is a circle\n            if (circle.getInterClusterEdges().length < 2) circle.setMayNotBeReversed();\n\n            circle.computeOrderMatrix();\n        }\n    });\n};\n\n/**\n * This method calculates the ideal edge length of each edge. Here we relax\n * edge lengths in the polishing step and keep the edge lengths of the edges\n * incident with inner-nodes very short to avoid overlaps.\n */\nCiSELayout.prototype.calcIdealEdgeLengths = function (isPolishingStep) {\n    var lEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < lEdges.length; i++) {\n        var edge = lEdges[i];\n\n        // Loosen in the polishing step to avoid overlaps\n        if (isPolishingStep) edge.idealLength = 1.5 * this.idealEdgeLength * this.idealInterClusterEdgeLengthCoefficient;else edge.idealLength = this.idealEdgeLength * this.idealInterClusterEdgeLengthCoefficient;\n    }\n\n    // Update in-nodes edge's lengths\n    var lNodes = this.graphManager.getInCircleNodes();\n    for (var _i14 = 0; _i14 < lNodes.length; _i14++) {\n        var node = lNodes[_i14];\n\n        node.getEdges().forEach(function (edge) {\n            edge.idealLength = CiSEConstants.DEFAULT_INNER_EDGE_LENGTH;\n        });\n    }\n};\n\n/**\n * This method calculates the spring forces applied to end nodes of each\n * edge. In steps 3 & 5, where on-circle nodes are not allowed to move,\n * intra-cluster edges are ignored (as their total will equal zero and won't\n * have an affect on the owner circle).\n */\nCiSELayout.prototype.calcSpringForces = function () {\n    var lEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < lEdges.length; i++) {\n        var edge = lEdges[i];\n        var source = edge.getSource();\n        var target = edge.getTarget();\n\n        // Ignore intra-cluster edges (all steps 3 thru 5) except for those\n        // incident w/ any inner-nodes\n        if (edge.isIntraCluster && source.getOnCircleNodeExt() != null && target.getOnCircleNodeExt() != null) {\n            continue;\n        }\n\n        this.calcSpringForce(edge, edge.idealLength);\n    }\n};\n\n/**\n * This method calculates the repulsion forces for each pair of nodes.\n * Repulsions need not be calculated for on-circle nodes.\n */\nCiSELayout.prototype.calcRepulsionForces = function () {\n    var lNodes = this.graphManager.getNonOnCircleNodes();\n    for (var i = 0; i < lNodes.length; i++) {\n        var nodeA = lNodes[i];\n        for (var j = i + 1; j < lNodes.length; j++) {\n            var nodeB = lNodes[j];\n\n            this.calcRepulsionForce(nodeA, nodeB);\n        }\n    }\n\n    // We need the calculate repulsion forces for in-circle nodes as well\n    // to keep them inside circle.\n    var inCircleNodes = this.graphManager.getInCircleNodes();\n    for (var _i15 = 0; _i15 < inCircleNodes.length; _i15++) {\n        var inCircleNode = inCircleNodes[_i15];\n        var ownerCircle = inCircleNode.getOwner();\n\n        //TODO: inner nodes repulse on-circle nodes as well, not desired!\n        // Calculate repulsion forces with all nodes inside the owner circle\n        // of this inner node.\n\n        var childNodes = ownerCircle.getNodes();\n        for (var _i16 = 0; _i16 < childNodes.length; _i16++) {\n            var childCiSENode = childNodes[_i16];\n\n            if (childCiSENode !== inCircleNode) {\n                this.calcRepulsionForce(inCircleNode, childCiSENode);\n            }\n        }\n    }\n};\n\n/**\n * This method calculates the gravitational forces for each node. On-circle\n * nodes move with their owner; thus they are not applied separate gravity.\n */\nCiSELayout.prototype.calcGravitationalForces = function () {\n    if (!this.graphManager.rootGraph.isConnected) {\n        var _lNodes = this.graphManager.getNonOnCircleNodes();\n\n        for (var i = 0; i < _lNodes.length; i++) {\n            var node = _lNodes[i];\n            this.calcGravitationalForce(node);\n        }\n    }\n\n    // Calculate gravitational forces to keep in-circle nodes in the center\n    // TODO: is this really helping or necessary?\n    var lNodes = this.graphManager.getInCircleNodes();\n\n    for (var _i17 = 0; _i17 < lNodes.length; _i17++) {\n        var _node = lNodes[_i17];\n        this.calcGravitationalForce(_node);\n    }\n};\n\n/**\n * This method adds up all the forces calculated earlier transferring forces\n * of on-circle nodes to their owner node (as regular and rotational forces)\n * when they are not allowed to move. When they are allowed to move,\n * on-circle nodes will partially contribute to the forces of their owner\n * circle (no rotational contribution).\n */\nCiSELayout.prototype.calcTotalForces = function () {\n    var allNodes = this.graphManager.getAllNodes();\n\n    for (var i = 0; i < allNodes.length; i++) {\n        var node = allNodes[i];\n\n        node.displacementX = this.coolingFactor * (node.springForceX + node.repulsionForceX + node.gravitationForceX);\n        node.displacementY = this.coolingFactor * (node.springForceY + node.repulsionForceY + node.gravitationForceY);\n\n        node.rotationAmount = 0.0;\n\n        node.springForceX = 0.0;\n        node.springForceY = 0.0;\n        node.repulsionForceX = 0.0;\n        node.repulsionForceY = 0.0;\n        node.gravitationForceX = 0.0;\n        node.gravitationForceY = 0.0;\n    }\n\n    var onCircleNodes = this.graphManager.getOnCircleNodes();\n    for (var _i18 = 0; _i18 < onCircleNodes.length; _i18++) {\n        var _node2 = onCircleNodes[_i18];\n        var parentNode = _node2.getOwner().getParent();\n        var values = _node2.getOwner().decomposeForce(_node2);\n\n        if (this.phase === CiSELayout.PHASE_SWAP_PREPERATION) {\n            _node2.getOnCircleNodeExt().addDisplacementForSwap(values.getRotationAmount());\n        }\n\n        parentNode.displacementX += values.getDisplacementX();\n        parentNode.displacementY += values.getDisplacementY();\n        _node2.displacementX = 0.0;\n        _node2.displacementY = 0.0;\n\n        parentNode.rotationAmount += values.getRotationAmount();\n        _node2.rotationAmount = 0.0;\n    }\n};\n\n/**\n * This method updates positions of each node at the end of an iteration.\n * Also, it deals with swapping of two consecutive nodes on a circle in\n * step 4.\n */\nCiSELayout.prototype.moveNodes = function () {\n    if (this.phase !== CiSELayout.PHASE_PERFORM_SWAP) {\n        var nonOnCircleNodes = this.graphManager.getNonOnCircleNodes();\n\n        // Simply move all non-on-circle nodes.\n        for (var i = 0; i < nonOnCircleNodes.length; i++) {\n            nonOnCircleNodes[i].move();\n\n            // Also make required rotations for circles\n            if (nonOnCircleNodes[i].getChild() !== null && nonOnCircleNodes[i].getChild() !== undefined) {\n                nonOnCircleNodes[i].getChild().rotate();\n            }\n        }\n\n        // Also move all in-circle nodes. Note that in-circle nodes will be\n        // empty if this option is not set, hence no negative effect on\n        // performance\n\n        var inCircleNodes = this.graphManager.getInCircleNodes();\n        var inCircleNode = void 0;\n\n        for (var _i19 = 0; _i19 < inCircleNodes.length; _i19++) {\n            inCircleNode = inCircleNodes[_i19];\n            // TODO: workaround to force inner nodes to stay inside\n            inCircleNode.displacementX /= 20.0;\n            inCircleNode.displacementY /= 20.0;\n            inCircleNode.move();\n        }\n    } else {\n        // If in perform-swap phase of step 4, we have to look for swappings\n        // that do not increase edge crossings and is likely to decrease total\n        // energy.\n        var ciseOnCircleNodes = this.graphManager.getOnCircleNodes();\n        var size = ciseOnCircleNodes.length;\n\n        // Both nodes of a pair are out-nodes, not necessarilly safe due to\n        // inter-cluster edge crossings\n        // TODO It should be a max heap structure\n        var nonSafePairs = [];\n\n        // Pairs where one of the on circle nodes is an in-node; no problem\n        // swapping these\n        var safePairs = [];\n\n        // Nodes swapped in this round\n        var swappedNodes = [];\n\n        // Pairs swapped or prevented from being swapped in this round\n        var swappedPairs = [];\n\n        var firstNode = void 0;\n        var secondNode = void 0;\n        var firstNodeExt = void 0;\n        var secondNodeExt = void 0;\n        var firstNodeDisp = void 0;\n        var secondNodeDisp = void 0;\n        var discrepancy = void 0;\n        var inSameDirection = void 0;\n\n        // Check each node with its next node for swapping\n        for (var _i20 = 0; _i20 < size; _i20++) {\n            firstNode = ciseOnCircleNodes[_i20];\n            secondNode = firstNode.getOnCircleNodeExt().getNextNode();\n            firstNodeExt = firstNode.getOnCircleNodeExt();\n            secondNodeExt = secondNode.getOnCircleNodeExt();\n\n            // Ignore if the swap is to introduce new intra-edge crossings\n            if (!firstNodeExt.canSwapWithNext || !secondNodeExt.canSwapWithPrev) continue;\n\n            firstNodeDisp = firstNodeExt.getDisplacementForSwap();\n            secondNodeDisp = secondNodeExt.getDisplacementForSwap();\n            discrepancy = firstNodeDisp - secondNodeDisp;\n\n            // Pulling in reverse directions, no swap\n            if (discrepancy < 0.0) continue;\n\n            // Might swap, create safe or nonsafe node pairs\n            inSameDirection = firstNodeDisp > 0 && secondNodeDisp > 0 || firstNodeDisp < 0 && secondNodeDisp < 0;\n            var pair = new CiSEOnCircleNodePair(firstNode, secondNode, discrepancy, inSameDirection);\n\n            // When both are out-nodes, nonsafe; otherwise, safe\n            if (firstNodeDisp === 0.0 || secondNodeDisp === 0.0) safePairs.push(pair);else nonSafePairs.push(pair);\n        }\n\n        var nonSafePair = void 0;\n        var lookForSwap = true;\n        var rollback = void 0;\n\n        // TODO max heap -> extractMax\n        nonSafePairs.sort(function (a, b) {\n            return a.getDiscrepancy() - b.getDiscrepancy();\n        });\n\n        // Look for a nonsafe pair until we swap one\n        while (lookForSwap && nonSafePairs.length > 0) {\n            // Pick the non safe pair that has the maximum discrepancy.\n            nonSafePair = nonSafePairs[nonSafePairs.length - 1];\n            firstNode = nonSafePair.getFirstNode();\n            secondNode = nonSafePair.getSecondNode();\n            firstNodeExt = firstNode.getOnCircleNodeExt();\n            secondNodeExt = secondNode.getOnCircleNodeExt();\n\n            // If this pair is swapped in previous swap phase, don't allow\n            // this swap. Also save it for the future as if it is actually\n            // swapped in order to prevent future oscilations\n            if (this.isSwappedPreviously(nonSafePair)) {\n                nonSafePairs.pop();\n                swappedPairs.push(nonSafePair);\n                continue;\n            }\n\n            // Check for inter-cluster edge crossings before swapping.\n            var int1 = firstNodeExt.getInterClusterIntersections(secondNodeExt);\n\n            // Try a swap\n            nonSafePair.swap();\n            rollback = false;\n\n            // Then re-compute crossings\n            var int2 = firstNodeExt.getInterClusterIntersections(secondNodeExt);\n\n            // Possible cases regarding discrepancy:\n            // first  second  action\n            // +      +       both clockwise: might swap if disp > 0\n            // +      -       disp > 0: might swap\n            // -      -       both counter-clockwise: might swap if disp > 0\n            // -      +       disp <= 0: no swap\n\n            // Under following conditions roll swap back:\n            // - swap increases inter-cluster edge crossings\n            // - inter-cluster edge number is the same but pulling in the\n            // same direction or discrepancy is below pre-determined\n            // threshold (not enough for swap)\n\n            rollback = int2 > int1;\n\n            if (!rollback && int2 === int1) {\n                rollback = nonSafePair.inSameDirection() || nonSafePair.getDiscrepancy() < CiSEConstants.MIN_DISPLACEMENT_FOR_SWAP;\n            }\n\n            if (rollback) {\n                nonSafePair.swap();\n                nonSafePairs.pop();\n                continue;\n            }\n\n            swappedNodes.push(nonSafePair.getFirstNode());\n            swappedNodes.push(nonSafePair.getSecondNode());\n            swappedPairs.push(nonSafePair);\n\n            // Swap performed, do not look for another nonsafe pair\n            lookForSwap = false;\n        }\n\n        // Now process all safe pairs\n        for (var _i21 = 0; _i21 < safePairs.length; _i21++) {\n            var safePair = safePairs[_i21];\n\n            // Check if discrepancy is above the threshold (enough to swap)\n            if (safePair.inSameDirection() || safePair.getDiscrepancy() < CiSEConstants.MIN_DISPLACEMENT_FOR_SWAP) {\n                continue;\n            }\n\n            // Check if they were already involved in a swap in this phase\n            if (swappedNodes.includes(safePair.getFirstNode()) || swappedNodes.includes(safePair.getSecondNode())) {\n                continue;\n            }\n\n            // Should be swapped if not previously swapped; so\n            // Check if they were previously swapped\n            if (!this.isSwappedPreviously(safePair)) {\n                safePair.swap();\n                swappedNodes.push(safePair.getFirstNode());\n                swappedNodes.push(safePair.getSecondNode());\n            }\n\n            // Mark swapped (even if not) to prevent future oscillations\n            swappedPairs.push(safePair);\n        }\n\n        // Update swap history\n        this.swappedPairsInLastIteration = [];\n        for (var _i22 = 0; _i22 < swappedPairs.length; _i22++) {\n            this.swappedPairsInLastIteration.push(swappedPairs[_i22]);\n        }\n\n        // Reset all discrepancy values of on circle nodes.\n        var node = void 0;\n\n        for (var _i23 = 0; _i23 < size; _i23++) {\n            node = ciseOnCircleNodes[_i23];\n            node.getOnCircleNodeExt().setDisplacementForSwap(0.0);\n        }\n    }\n};\n\n/*\n * This method returns whether or not the input node pair was previously\n * swapped.\n */\nCiSELayout.prototype.isSwappedPreviously = function (pair) {\n    for (var i = 0; i < this.swappedPairsInLastIteration.length; i++) {\n        var swappedPair = this.swappedPairsInLastIteration[i];\n\n        if (swappedPair.getFirstNode() === pair.getFirstNode() && swappedPair.getSecondNode() === pair.getSecondNode() || swappedPair.getSecondNode() === pair.getFirstNode() && swappedPair.getFirstNode() === pair.getSecondNode()) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n/**\n* This method tries to improve the edge crossing number by reversing a\n* cluster (i.e., the order of the nodes in the cluster such as C,B,A\n* instead of A,B,C). No more than one reversal is performed with each\n* execution. The decision is based on the global sequence alignment\n* heuristic (typically used in biological sequence alignment). A cluster\n* that was previsouly reversed is not a candidate for reversal to avoid\n* oscillations. It returns true if a reversal has been performed.\n*/\nCiSELayout.prototype.checkAndReverseIfReverseIsBetter = function () {\n    var gm = this.getGraphManager();\n\n    // For each cluster (in no particular order) check to see whether\n    // reversing the order of the nodes on the cluster could improve on\n    // inter-graph edge crossing number of that cluster.\n\n    var nodeIterator = gm.getRoot().getNodes();\n    var node = void 0;\n    var circle = void 0;\n\n    for (var i = 0; i < nodeIterator.length; i++) {\n        node = nodeIterator[i];\n        circle = node.getChild();\n\n        if (circle != null && circle.getMayBeReversed() && circle.getNodes().length <= 52) {\n            if (circle.checkAndReverseIfReverseIsBetter()) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * This method goes over all circles and tries to find nodes that can be\n * moved inside the circle. Inner nodes are found and moved inside one at a\n * time. This process continues for a circle until either there is no inner\n * node or reached max inner nodes for that circle.\n */\nCiSELayout.prototype.findAndMoveInnerNodes = function () {\n    if (!this.allowNodesInsideCircle) {\n        return;\n    }\n\n    var graphs = this.graphManager.getGraphs();\n    for (var i = 0; i < graphs.length; i++) {\n        var ciseCircle = graphs[i];\n\n        // Count inner nodes not to exceed user defined maximum\n        var innerNodeCount = 0;\n\n        if (ciseCircle !== this.getGraphManager().getRoot()) {\n            // It is a user parameter, retrieve it.\n            var maxInnerNodes = ciseCircle.getNodes().length * this.maxRatioOfNodesInsideCircle;\n\n            // Look for an inner node and move it inside\n            var innerNode = this.findInnerNode(ciseCircle);\n\n            while (innerNode !== null && innerNode !== undefined && innerNodeCount < maxInnerNodes) {\n                this.moveInnerNode(innerNode);\n                innerNodeCount++;\n\n                if (innerNodeCount < maxInnerNodes) {\n                    innerNode = this.findInnerNode(ciseCircle);\n                }\n            }\n        }\n    }\n};\n\n/**\n * This method finds an inner node (if any) in the given circle.\n */\nCiSELayout.prototype.findInnerNode = function (ciseCircle) {\n    var innerNode = null;\n    var onCircleNodeCount = ciseCircle.getOnCircleNodes().length;\n\n    // First sort the nodes in the circle according to their degrees.\n    var sortedNodes = ciseCircle.getOnCircleNodes();\n    sortedNodes.sort(function (a, b) {\n        return a.getEdges().length - b.getEdges().length;\n    });\n\n    // Evaluate each node as possible candidate\n    for (var i = onCircleNodeCount - 1; i >= 0 && innerNode == null; i--) {\n        var candidateNode = sortedNodes[i];\n\n        // Out nodes cannot be moved inside, so just skip them\n        if (candidateNode.getOnCircleNodeExt().getInterClusterEdges().length !== 0) {\n            continue;\n        }\n\n        var circleSegment = this.findMinimalSpanningSegment(candidateNode);\n\n        // Skip nodes with no neighbors (circle segment will be empty)\n        if (circleSegment.length === 0) {\n            continue;\n        }\n\n        // For all nodes in the spanning circle segment, check if that node\n        // is connected to another node on the circle with an index diff of\n        // greater than 1 (i.e. connected to a non-immediate neighbor)\n\n        var connectedToNonImmediate = false;\n\n        for (var _i24 = 0; _i24 < circleSegment.length; _i24++) {\n            var spanningNode = circleSegment[_i24];\n\n            // Performance improvement: stop iteration if this cannot be\n            // an inner node.\n            if (connectedToNonImmediate) {\n                break;\n            }\n\n            // Look for neighbors of this spanning node.\n            var neighbors = spanningNode.getNeighborsList();\n            for (var j = 0; j < neighbors.length; j++) {\n                var neighborOfSpanningNode = neighbors[j];\n\n                // In some case we don't need to look at the neighborhood\n                // relationship. We won't care the neighbor of spanning node\n                // if:\n                // - It is the candidate node\n                // - It is on another circle\n                // - It is already an inner node.\n                if (neighborOfSpanningNode !== candidateNode && neighborOfSpanningNode.getOwner() === ciseCircle && neighborOfSpanningNode.getOnCircleNodeExt() != null && neighborOfSpanningNode.getOnCircleNodeExt() != undefined) {\n\n                    var spanningIndex = spanningNode.getOnCircleNodeExt().getIndex();\n                    var neighborOfSpanningIndex = neighborOfSpanningNode.getOnCircleNodeExt().getIndex();\n\n                    // Calculate the index difference between spanning node\n                    // and its neighbor\n                    var indexDiff = spanningIndex - neighborOfSpanningIndex;\n                    indexDiff += onCircleNodeCount; // Get rid of neg. index\n                    indexDiff %= onCircleNodeCount; // Mod it\n\n                    // Give one more chance, try reverse order of nodes\n                    // just in case.\n                    if (indexDiff > 1) {\n                        indexDiff = neighborOfSpanningIndex - spanningIndex;\n                        indexDiff += onCircleNodeCount; // Get rid of neg.\n                        indexDiff %= onCircleNodeCount; // Mod it\n                    }\n\n                    // If the diff is still greater 1, this spanning node\n                    // has a non-immediate neighbor. Sorry but you cannot\n                    // be an inner node. Poor candidate node !!!\n                    if (indexDiff > 1) {\n                        connectedToNonImmediate = true;\n                        // stop computation.\n                        break;\n                    }\n                }\n            }\n        }\n\n        // If neighbors of candidate node is not connect to a non-immediate\n        // neighbor that this can be an inner node.\n        if (!connectedToNonImmediate) {\n            innerNode = candidateNode;\n        }\n    }\n\n    return innerNode;\n};\n\n/**\n * This method safely removes inner node from circle perimeter (on-circle)\n * and moves them inside their owner circles (as in-circle nodes)\n */\nCiSELayout.prototype.moveInnerNode = function (innerNode) {\n    var ciseCircle = innerNode.getOwner();\n\n    // Remove the node from the circle first. This forces circle to\n    // re-adjust its geometry. A costly operation indeed...\n    ciseCircle.moveOnCircleNodeInside(innerNode);\n\n    // We need to also remove the inner node from on-circle nodes list\n    // of the associated graph manager\n    var onCircleNodesList = this.graphManager.getOnCircleNodes();\n    var index = onCircleNodesList.indexOf(innerNode);\n    if (index > -1) {\n        onCircleNodesList.splice(index, 1);\n    }\n\n    this.graphManager.inCircleNodes.push(innerNode);\n};\n\n/**\n * This method returns a circular segment (ordered array of nodes),\n * which is the smallest segment that spans neighbors of the given node.\n */\nCiSELayout.prototype.findMinimalSpanningSegment = function (node) {\n    var segment = [];\n\n    // First create an ordered neighbors list which includes given node and\n    // its neighbors and ordered according to their indexes in this circle.\n    var orderedNeigbors = node.getOnCircleNeighbors();\n\n    if (orderedNeigbors.length === 0) {\n        return segment;\n    }\n\n    orderedNeigbors.sort(function (a, b) {\n        return a.getOnCircleNodeExt().getIndex() - b.getOnCircleNodeExt().getIndex();\n    });\n\n    // According to the order found, find the start and end nodes of the\n    // segment by testing each (order adjacent) neighbor pair.\n    var orderedNodes = node.getOwner().getOnCircleNodes();\n    orderedNodes.sort(function (a, b) {\n        return a.getOnCircleNodeExt().getIndex() - b.getOnCircleNodeExt().getIndex();\n    });\n\n    var shortestSegmentStartNode = null;\n    var shortestSegmentEndNode = null;\n    var shortestSegmentLength = orderedNodes.length;\n    var segmentLength = orderedNodes.length;\n    var neighSize = orderedNeigbors.length;\n    var i = void 0;\n    var j = void 0;\n    var tempSegmentStartNode = void 0;\n    var tempSegmentEndNode = void 0;\n    var tempSegmentLength = void 0;\n\n    for (i = 0; i < neighSize; i++) {\n        j = (i - 1 + neighSize) % neighSize;\n\n        tempSegmentStartNode = orderedNeigbors[i];\n        tempSegmentEndNode = orderedNeigbors[j];\n\n        tempSegmentLength = (tempSegmentEndNode.getOnCircleNodeExt().getIndex() - tempSegmentStartNode.getOnCircleNodeExt().getIndex() + segmentLength) % segmentLength + 1;\n\n        if (tempSegmentLength < shortestSegmentLength) {\n            shortestSegmentStartNode = tempSegmentStartNode;\n            shortestSegmentEndNode = tempSegmentEndNode;\n            shortestSegmentLength = tempSegmentLength;\n        }\n    }\n\n    // After finding start and end nodes for the segment, simply go over\n    // ordered nodes and create an ordered list of nodes in the segment\n\n    var segmentEndReached = false;\n    var currentNode = shortestSegmentStartNode;\n\n    while (!segmentEndReached) {\n        if (currentNode !== node) {\n            segment.push(currentNode);\n        }\n\n        if (currentNode === shortestSegmentEndNode) {\n            segmentEndReached = true;\n        } else {\n            var nextIndex = currentNode.getOnCircleNodeExt().getIndex() + 1;\n\n            if (nextIndex === orderedNodes.length) {\n                nextIndex = 0;\n            }\n\n            currentNode = orderedNodes[nextIndex];\n        }\n    }\n\n    return segment;\n};\n\nmodule.exports = CiSELayout;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class implements data and functionality required for CiSE layout per\n * node.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar FDLayoutNode = __webpack_require__(0).layoutBase.FDLayoutNode;\nvar IMath = __webpack_require__(0).layoutBase.IMath;\nvar CiSEConstants = __webpack_require__(1);\nvar CiSEOnCircleNodeExt = __webpack_require__(12);\n\nfunction CiSENode(gm, loc, size, vNode) {\n    // the constructor of LNode handles alternative constructors\n    FDLayoutNode.call(this, gm, loc, size, vNode);\n\n    // Amount by which this node will be rotated in this iteration. Note that\n    // clockwise rotation is positive and counter-clockwise is negative.\n    this.rotationAmount = null;\n\n    // Extension for on-circle nodes\n    this.onCircleNodeExt = null; //Extension for on-circle nodes\n\n    // Cluster ID which the node belongs to\n    this.clusterID = null;\n\n    // Cytoscape node ID for transforming between layout and cytoscape\n    this.ID = null;\n}\n\nCiSENode.prototype = Object.create(FDLayoutNode.prototype);\n\nfor (var prop in FDLayoutNode) {\n    CiSENode[prop] = FDLayoutNode[prop];\n}\n\n// -----------------------------------------------------------------------------\n// Section: Accessors and mutators\n// -----------------------------------------------------------------------------\n\nCiSENode.prototype.setClusterId = function (cID) {\n    this.clusterID = cID;\n};\n\nCiSENode.prototype.getClusterId = function () {\n    return this.clusterID;\n};\n\nCiSENode.prototype.setId = function (ID) {\n    this.ID = ID;\n};\n\nCiSENode.prototype.getId = function () {\n    return this.ID;\n};\n\n/**\n * This method sets this node as an on-circle node by creating an extension for it.\n */\nCiSENode.prototype.setAsOnCircleNode = function () {\n    this.onCircleNodeExt = new CiSEOnCircleNodeExt(this);\n    return this.onCircleNodeExt;\n};\n\n/**\n * This method sets this node as an non on-circle node by deleting the\n * extension for it.\n */\nCiSENode.prototype.setAsNonOnCircleNode = function () {\n    this.onCircleNodeExt = null;\n};\n\n/**\n * This method returns the extension of this node for on-circle nodes. This\n * extension is null if this node is a non-on-circle node.\n */\nCiSENode.prototype.getOnCircleNodeExt = function () {\n    return this.onCircleNodeExt;\n};\n\n/**\n * This method limits the input displacement with the maximum possible.\n */\nCiSENode.prototype.getLimitedDisplacement = function (displacement) {\n    if (Math.abs(displacement) > CiSEConstants.MAX_NODE_DISPLACEMENT) displacement = CiSEConstants.MAX_NODE_DISPLACEMENT * IMath.sign(displacement);\n\n    return displacement;\n};\n\n/**\n * This method returns neighbors of this node which are on-circle, not\n * in-circle.\n */\nCiSENode.prototype.getOnCircleNeighbors = function () {\n    var neighbors = Array.from(this.getNeighborsList());\n    var onCircleNeighbors = [];\n\n    for (var i = 0; i < neighbors.length; i++) {\n        var node = neighbors[i];\n\n        if (node.getOnCircleNodeExt() !== null && node.getClusterId() === this.getClusterId()) onCircleNeighbors.push(node);\n    }\n\n    return onCircleNeighbors;\n};\n\n/**\n * This method returns the number of children (weight) of this node.\n * If it is a compound, then return the number of simple nodes inside,\n * otherwise return 1.\n */\nCiSENode.prototype.getNoOfChildren = function () {\n    if (this.getChild() === null || this.getChild() === undefined) return 1;else return this.getChild().getNodes().length;\n};\n\n// -----------------------------------------------------------------------------\n// Section: Remaining methods\n// -----------------------------------------------------------------------------\n\n/**\n * This method moves this node as a result of the computations at the end of\n * this iteration.\n */\nCiSENode.prototype.move = function () {\n    var layout = this.getOwner().getGraphManager().getLayout();\n\n    this.displacementX = this.getLimitedDisplacement(this.displacementX);\n    this.displacementY = this.getLimitedDisplacement(this.displacementY);\n\n    // First propagate movement to children if it's a circle\n    if (this.getChild() !== null && this.getChild() !== undefined) {\n        // Take size into account when reflecting total force into movement!\n        var noOfNodesOnCircle = this.getChild().getNodes().length;\n        this.displacementX /= noOfNodesOnCircle;\n        this.displacementY /= noOfNodesOnCircle;\n\n        var children = this.getChild().getNodes();\n\n        for (var i = 0; i < children.length; i++) {\n            var node = children[i];\n\n            node.moveBy(this.displacementX, this.displacementY);\n            layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n        }\n    }\n\n    this.moveBy(this.displacementX, this.displacementY);\n    layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n\n    if (this.getChild() !== null && this.getChild() !== undefined) {\n        this.getChild().updateBounds(true);\n    }\n};\n\n/**\n * This method resets displacement values\n */\nCiSENode.prototype.reset = function () {\n    this.displacementX = 0.0;\n    this.displacementY = 0.0;\n};\n\nmodule.exports = CiSENode;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n/**\n * This class implements data and functionality required for CiSE layout per\n * on-circle node. In other words, it is an extension to CiSENode class for\n * on-circle nodes.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar IGeometry = __webpack_require__(0).layoutBase.IGeometry;\n\n// -----------------------------------------------------------------------------\n// Section: Constructors and initializations\n// -----------------------------------------------------------------------------\n\n\nfunction CiSEOnCircleNodeExt(ciseNode) {\n    // Associated CiSE node\n    this.ciseNode = ciseNode;\n\n    // Holds the intra-cluster edges of this node, initially it is null. It\n    // will be calculated and stored when getIntraClusterEdges method is first\n    // called.\n    this.intraClusterEdges = null;\n\n    // Holds the inter-cluster edges of this node, initially it is null. It\n    // will be calculated and stored when getInterClusterEdges method is first\n    // called.\n    this.interClusterEdges = null;\n\n    // Holds relative position of this node with respect to its owner circle\n    // It is less than 0 (=-1) only if not assigned. Its unit is radian.\n    this.angle = -1;\n\n    // Holds current index of this node within its owner circle; it is -1 if not\n    // assigned.\n    this.orderIndex = -1;\n\n    // Indicates whether a swapping with next node in the owner circle order\n    // will cause no additional crossings or not.\n    this.canSwapWithNext = null;\n\n    // Indicates whether a swapping with previous node in the owner circle order\n    // will cause no additional crossings or not.\n    this.canSwapWithPrevious = null;\n\n    // Holds the total weighted displacement value calculated over a constant\n    // number of iterations used for deciding whether two nodes should be\n    // swapped.\n    this.displacementForSwap = null;\n}\n\nCiSEOnCircleNodeExt.prototype = Object.create(null);\n\n// -----------------------------------------------------------------------------\n// Section: Accessors and mutators\n// -----------------------------------------------------------------------------\n\n\n// This function returns the associated CiSENode\nCiSEOnCircleNodeExt.prototype.getCiseNode = function () {\n    return this.ciseNode;\n};\n\n// This function returns the relative position of this node\n// within it's owner circle\nCiSEOnCircleNodeExt.prototype.getAngle = function () {\n    return this.angle;\n};\n\n// This function sets the relative position of this node within its owner\n// circle. We keep the angle positive for easy debugging.\nCiSEOnCircleNodeExt.prototype.setAngle = function (angle) {\n    this.angle = angle % IGeometry.TWO_PI;\n    if (this.angle < 0) {\n        this.angle += IGeometry.TWO_PI;\n    }\n};\n\n// This function returns current index of this in it's owner circle\nCiSEOnCircleNodeExt.prototype.getIndex = function () {\n    return this.orderIndex;\n};\n\n// This function sets current index of this node in its owner circle.\nCiSEOnCircleNodeExt.prototype.setIndex = function (index) {\n    this.orderIndex = index;\n};\n\n/**\n * This method returns the char code of this node based on the node index.\n * First node of the cluster is 'a', second one is 'b\", and so on. We only\n * guarentee a unique char code up to 52 nodes in a cluster.\n *\n * Remember in ASCII, 'a' is 97 and 'A' is 65. In Unicode, 'A' has a bigger decimal value\n */\nCiSEOnCircleNodeExt.prototype.getCharCode = function () {\n    var charCode = void 0;\n\n    if (this.orderIndex < 26) charCode = String.fromCharCode(97 + this.orderIndex);else if (this.orderIndex < 52) charCode = String.fromCharCode(65 + this.orderIndex);else charCode = '?';\n\n    return charCode;\n};\n\n/**\n * This method returns the next node according to current ordering of the\n * owner circle.\n */\nCiSEOnCircleNodeExt.prototype.getNextNode = function () {\n    var circle = this.ciseNode.getOwner();\n    var totalNodes = circle.getOnCircleNodes().length;\n    var nextNodeIndex = this.orderIndex + 1;\n\n    if (nextNodeIndex === totalNodes) nextNodeIndex = 0;\n\n    return circle.getOnCircleNodes()[nextNodeIndex];\n};\n\n/**\n * This method returns the previous node according to current ordering of\n * the owner circle.\n */\nCiSEOnCircleNodeExt.prototype.getPrevNode = function () {\n    var circle = this.ciseNode.getOwner();\n    var nextNodeIndex = this.orderIndex - 1;\n\n    if (nextNodeIndex === -1) {\n        nextNodeIndex = circle.getOnCircleNodes().length - 1;\n    }\n\n    return circle.getOnCircleNodes()[nextNodeIndex];\n};\n\n/**\n * This method returns the extension of the next node according to current\n * ordering of the owner circle.\n */\nCiSEOnCircleNodeExt.prototype.getNextNodeExt = function () {\n    return this.getNextNode().getOnCircleNodeExt();\n};\n\n/**\n * This method returns the extension of the previous node according to\n * current ordering of the owner circle.\n */\nCiSEOnCircleNodeExt.prototype.prevNextNodeExt = function () {\n    return this.getPrevNode().getOnCircleNodeExt();\n};\n\nCiSEOnCircleNodeExt.prototype.canSwapWithNext = function () {\n    return this.canSwapWithNext;\n};\n\nCiSEOnCircleNodeExt.prototype.canSwapWithPrev = function () {\n    return this.canSwapWithPrev;\n};\n\nCiSEOnCircleNodeExt.prototype.getDisplacementForSwap = function () {\n    return this.displacementForSwap;\n};\n\nCiSEOnCircleNodeExt.prototype.setDisplacementForSwap = function (displacementForSwap) {\n    this.displacementForSwap = displacementForSwap;\n};\n\nCiSEOnCircleNodeExt.prototype.addDisplacementForSwap = function (displacementIncrForSwap) {\n    this.displacementForSwap = displacementIncrForSwap;\n    // This is what we intended (but above seems to work better):\n    //\t\tthis.displacementForSwap = (this.displacementForSwap +\n    //\t\t\tdisplacementIncrForSwap) / 2.0;\n};\n\n// -----------------------------------------------------------------------------\n// Section: Remaining methods\n// -----------------------------------------------------------------------------\n\n/**\n * This method updates the absolute position of this node with respect to\n * its angle and the position of node that owns the owner circle.\n */\nCiSEOnCircleNodeExt.prototype.updatePosition = function () {\n    var ownerGraph = this.ciseNode.getOwner();\n    var parentNode = ownerGraph.getParent();\n\n    var parentX = parentNode.getCenterX();\n    var parentY = parentNode.getCenterY();\n\n    var xDifference = ownerGraph.getRadius() * Math.cos(this.angle);\n    var yDifference = ownerGraph.getRadius() * Math.sin(this.angle);\n\n    this.ciseNode.setCenter(parentX + xDifference, parentY + yDifference);\n};\n\n/**\n * This method returns the index difference of this node with the input\n * node. Note that the index difference cannot be negative if both nodes are\n * placed on the circle. Here -1 means at least one of the nodes are not yet\n * placed on the circle.\n */\nCiSEOnCircleNodeExt.prototype.getCircDistWithTheNode = function (refNode) {\n    var otherIndex = refNode.getIndex();\n\n    if (otherIndex === -1 || this.getIndex() === -1) {\n        return -1;\n    }\n\n    var diff = this.getIndex() - otherIndex;\n\n    if (diff < 0) {\n        diff += this.ciseNode.getOwner().getOnCircleNodes().length;\n    }\n\n    return diff;\n};\n\n/**\n * This method calculates the total number of crossings the edges of this\n * node cause.\n */\nCiSEOnCircleNodeExt.prototype.calculateTotalCrossing = function () {\n    var intraEdges = this.getIntraClusterEdges();\n    var count = 0;\n    var temp = [];\n\n    this.ciseNode.getOwner().getIntraClusterEdges().forEach(function (edge) {\n        temp.push(edge);\n    });\n\n    this.ciseNode.getEdges().forEach(function (edge) {\n        var index = temp.indexOf(edge);\n        if (index > -1) {\n            temp.splice(index, 1);\n        }\n    });\n\n    intraEdges.forEach(function (edge) {\n        count += edge.calculateTotalCrossingWithList(temp);\n    });\n\n    return count;\n};\n\n/**\n * This method updates the conditions for swapping of this node with its\n * previous and next neighbors on the associated circle.\n */\nCiSEOnCircleNodeExt.prototype.updateSwappingConditions = function () {\n    // Current values\n    var currentCrossingNumber = this.calculateTotalCrossing();\n    var currentNodeIndex = this.orderIndex;\n\n    // What will happen if node is swapped with next\n    var nextNodeExt = this.getNextNode().getOnCircleNodeExt();\n    this.orderIndex = nextNodeExt.getIndex();\n    nextNodeExt.setIndex(currentNodeIndex);\n\n    var tempCrossingNumber = this.calculateTotalCrossing();\n    this.canSwapWithNext = tempCrossingNumber <= currentCrossingNumber;\n\n    // Reset indices\n    nextNodeExt.setIndex(this.orderIndex);\n    this.setIndex(currentNodeIndex);\n\n    // What will happen if node is swapped with prev\n    var prevNodeExt = this.getPrevNode().getOnCircleNodeExt();\n    this.orderIndex = prevNodeExt.getIndex();\n    prevNodeExt.setIndex(currentNodeIndex);\n\n    tempCrossingNumber = this.calculateTotalCrossing();\n    this.canSwapWithPrevious = tempCrossingNumber <= currentCrossingNumber;\n\n    // Reset indices\n    prevNodeExt.setIndex(this.orderIndex);\n    this.setIndex(currentNodeIndex);\n};\n\n/**\n * This method swaps this node with the specified neighbor (prev or next).\n */\nCiSEOnCircleNodeExt.prototype.swapWith = function (neighborExt) {\n    this.ciseNode.getOwner().swapNodes(this.ciseNode, neighborExt.ciseNode);\n};\n\n/**\n * This method finds the number of crossings of inter cluster edges of this\n * node with the inter cluster edges of the other node.\n */\nCiSEOnCircleNodeExt.prototype.getInterClusterIntersections = function (other) {\n    var count = 0;\n\n    var thisInterClusterEdges = this.getInterClusterEdges();\n    var otherInterClusterEdges = other.getInterClusterEdges();\n\n    for (var i = 0; i < thisInterClusterEdges.length; i++) {\n        var edge = thisInterClusterEdges[i];\n\n        var point1 = this.ciseNode.getCenter();\n        var point2 = edge.getOtherEnd(this.ciseNode).getCenter();\n\n        for (var j = 0; j < otherInterClusterEdges.length; j++) {\n            var otherEdge = otherInterClusterEdges[j];\n            var point3 = other.ciseNode.getCenter();\n            var point4 = otherEdge.getOtherEnd(other.ciseNode).getCenter();\n\n            if (edge.getOtherEnd(this.ciseNode) !== otherEdge.getOtherEnd(other.ciseNode)) {\n                var result = IGeometry.doIntersect(point1, point2, point3, point4);\n\n                if (result) count++;\n            }\n        }\n    }\n\n    return count;\n};\n\n/**\n * This method returns the inter cluster edges of the associated node.\n */\nCiSEOnCircleNodeExt.prototype.getInterClusterEdges = function () {\n    if (this.interClusterEdges === null) {\n        //first time accessing\n        this.interClusterEdges = [];\n        var edgesOfNode = this.ciseNode.getEdges();\n        for (var i = 0; i < edgesOfNode.length; i++) {\n            var edge = edgesOfNode[i];\n            if (!edge.isIntraCluster) {\n                this.interClusterEdges.push(edge);\n            }\n        }\n    }\n\n    return this.interClusterEdges;\n};\n\n/**\n * This method returns the intra cluster edges of the associated node.\n */\nCiSEOnCircleNodeExt.prototype.getIntraClusterEdges = function () {\n    if (this.intraClusterEdges === null) {\n        //first time accessing\n        this.intraClusterEdges = [];\n        var edgesOfNode = this.ciseNode.getEdges();\n        for (var i = 0; i < edgesOfNode.length; i++) {\n            var edge = edgesOfNode[i];\n            if (edge.isIntraCluster) {\n                this.intraClusterEdges.push(edge);\n            }\n        }\n    }\n\n    return this.intraClusterEdges;\n};\n\nmodule.exports = CiSEOnCircleNodeExt;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class implements a pair of on-circle nodes used for swapping in phase 4.\n *\n */\n\n// -----------------------------------------------------------------------------\n// Section: Constructors and initializations\n// -----------------------------------------------------------------------------\n\nfunction CiSEOnCircleNodePair(first, second, displacement, inSameDirection) {\n    // The node of the pair which comes first in the ordering of its owner\n    // circle.\n    this.firstNode = first;\n\n    // The node of the pair which comes second in the ordering of its owner\n    // circle.\n    this.secondNode = second;\n\n    // The discrepancy of the displacement values of two nodes, indicating the\n    // swapping potential of the two nodes. Higher value means that nodes are\n    // more inclined to swap.\n    this.discrepancy = displacement;\n\n    // Whether or not the two nodes are pulling in the same direction\n    this.inSameDir = inSameDirection;\n}\n\nCiSEOnCircleNodePair.prototype = Object.create;\n\n// -----------------------------------------------------------------------------\n// Section: Accessors\n// -----------------------------------------------------------------------------\n\nCiSEOnCircleNodePair.prototype.getDiscrepancy = function () {\n    return this.discrepancy;\n};\n\nCiSEOnCircleNodePair.prototype.inSameDirection = function () {\n    return this.inSameDir;\n};\n\nCiSEOnCircleNodePair.prototype.getFirstNode = function () {\n    return this.firstNode;\n};\n\nCiSEOnCircleNodePair.prototype.getSecondNode = function () {\n    return this.secondNode;\n};\n\n// -----------------------------------------------------------------------------\n// Section: Remaining methods\n// -----------------------------------------------------------------------------\n\nCiSEOnCircleNodePair.prototype.compareTo = function (other) {\n    return this.getDiscrepancy() - other.getDiscrepancy();\n};\n\nCiSEOnCircleNodePair.prototype.swap = function () {\n    this.getFirstNode().getOnCircleNodeExt().swapWith(this.getSecondNode().getOnCircleNodeExt());\n};\n\nCiSEOnCircleNodePair.prototype.equals = function (other) {\n    var result = other instanceof CiSEOnCircleNodePair;\n\n    if (result) {\n        var pair = other;\n\n        result &= this.firstNode.equals(pair.getFirstNode()) && this.secondNode.equals(pair.getSecondNode()) || this.secondNode.equals(pair.getFirstNode()) && this.firstNode.equals(pair.getSecondNode());\n    }\n\n    return result;\n};\n\nCiSEOnCircleNodePair.prototype.hashCode = function () {\n    return this.firstNode.hashCode() + this.secondNode.hashCode();\n};\n\nCiSEOnCircleNodePair.prototype.toString = function () {\n    var result = \"Swap: \" + this.getFirstNode().label;\n    result += \"<->\" + this.getSecondNode().label;\n    result += \", \" + this.getDiscrepancy();\n\n    return result;\n};\n\nmodule.exports = CiSEOnCircleNodePair;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class is a utility class that is used to store the rotation amount,\n * x-axis displacement and y-axis displacement components of a force that act\n * upon an on-circle node. The calculation for this is done in CiSECircle for\n * specified on-circle node. Here we assume that forces on on-circle nodes can\n * be modelled with forces acting upon the perimeter of a circular flat, rigid\n * object sitting on a 2-dimensional surface, free to move in a direction\n * without any friction. Thus, such an object is assumed to move and rotate on\n * this force in amounts proportional to the total force (not just the vertical\n * component of the force!) and the component of the force that is tangential to\n * the circular shape of the object, respectively.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\n// -----------------------------------------------------------------------------\n// Section: Constructors and initializations\n// -----------------------------------------------------------------------------\n\nfunction CircularForce(rotationAmount, displacementX, displacementY) {\n    // This is the rotation amount that is to be assigned to the rotationAmount\n    // of a CiSENode\n    this.rotationAmount = rotationAmount;\n\n    // This is the x-axis displacement value that is to be assigned to the displacementX\n    // of a CiSENode\n    this.displacementX = displacementX;\n\n    // This is the y-axis displacement value that is to be assigned to the displacementY\n    // of a CiSENode\n    this.displacementY = displacementY;\n}\n\n// -----------------------------------------------------------------------------\n// Section: Accessors and mutators\n// -----------------------------------------------------------------------------\n\nCircularForce.prototype.getRotationAmount = function () {\n    return this.rotationAmount;\n};\n\nCircularForce.prototype.setRotationAmount = function (rotationAmount) {\n    this.rotationAmount = rotationAmount;\n};\n\nCircularForce.prototype.getDisplacementX = function () {\n    return this.displacementX;\n};\n\nCircularForce.prototype.setDisplacementX = function (displacementX) {\n    this.displacementX = displacementX;\n};\n\nCircularForce.prototype.getDisplacementY = function () {\n    return this.displacementY;\n};\n\nCircularForce.prototype.setDisplacementY = function (displacementY) {\n    this.displacementY = displacementY;\n};\n\nmodule.exports = CircularForce;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar impl = __webpack_require__(4);\n\n// registers the extension on a cytoscape lib ref\nvar register = function register(cytoscape) {\n  if (!cytoscape) {\n    return;\n  } // can't register if cytoscape unspecified\n\n  cytoscape('layout', 'cise', impl); // register with cytoscape.js\n};\n\nif (typeof cytoscape !== 'undefined') {\n  // expose to global cytoscape (i.e. window.cytoscape)\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * This class builds the required connection between CiSE elements and Cytoscape extension elements\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar CiSELayout = __webpack_require__(10);\nvar CiSEConstants = __webpack_require__(1);\nvar FDLayoutConstants = __webpack_require__(0).layoutBase.FDLayoutConstants;\n\nvar ContinuousLayout = __webpack_require__(18);\nvar defaults = ContinuousLayout.defaults;\nvar assign = __webpack_require__(2);\nvar isFn = function isFn(fn) {\n  return typeof fn === 'function';\n};\n\nvar optFn = function optFn(opt, ele) {\n  if (isFn(opt)) {\n    return opt(ele);\n  } else {\n    return opt;\n  }\n};\n\nvar Layout = function (_ContinuousLayout) {\n  _inherits(Layout, _ContinuousLayout);\n\n  function Layout(options) {\n    _classCallCheck(this, Layout);\n\n    //Changing CiSEConstants if there is a particular option defined in 'options' part of Layout call\n    var _this = _possibleConstructorReturn(this, (Layout.__proto__ || Object.getPrototypeOf(Layout)).call(this, assign({}, defaults, options)));\n\n    if (options.nodeSeparation !== null && options.nodeSeparation !== undefined) CiSEConstants.DEFAULT_NODE_SEPARATION = options.nodeSeparation;else CiSEConstants.DEFAULT_NODE_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 4;\n\n    if (options.idealInterClusterEdgeLengthCoefficient !== null && options.idealInterClusterEdgeLengthCoefficient !== undefined) CiSEConstants.DEFAULT_IDEAL_INTER_CLUSTER_EDGE_LENGTH_COEFF = options.idealInterClusterEdgeLengthCoefficient;else CiSEConstants.DEFAULT_IDEAL_INTER_CLUSTER_EDGE_LENGTH_COEFF = 1.4;\n\n    if (options.allowNodesInsideCircle !== null && options.allowNodesInsideCircle !== undefined) CiSEConstants.DEFAULT_ALLOW_NODES_INSIDE_CIRCLE = options.allowNodesInsideCircle;else CiSEConstants.DEFAULT_ALLOW_NODES_INSIDE_CIRCLE = false;\n\n    if (options.maxRatioOfNodesInsideCircle !== null && options.maxRatioOfNodesInsideCircle !== undefined) CiSEConstants.DEFAULT_MAX_RATIO_OF_NODES_INSIDE_CIRCLE = options.maxRatioOfNodesInsideCircle;else CiSEConstants.DEFAULT_MAX_RATIO_OF_NODES_INSIDE_CIRCLE = 0.1;\n\n    if (options.springCoeff !== null && options.springCoeff !== undefined) CiSEConstants.DEFAULT_SPRING_STRENGTH = options.springCoeff;else CiSEConstants.DEFAULT_SPRING_STRENGTH = 1.5 * FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n\n    if (options.nodeRepulsion != null) CiSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;\n\n    if (options.gravity != null) CiSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n\n    if (options.gravityRange != null) CiSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n\n    if (options.maxRatioOfNodesInsideCircle !== null && options.maxRatioOfNodesInsideCircle !== undefined) CiSEConstants.DEFAULT_MAX_RATIO_OF_NODES_INSIDE_CIRCLE = options.maxRatioOfNodesInsideCircle;else CiSEConstants.DEFAULT_MAX_RATIO_OF_NODES_INSIDE_CIRCLE = 0.1;\n    return _this;\n  }\n\n  _createClass(Layout, [{\n    key: 'prerun',\n    value: function prerun() {\n      var state = this.state;\n\n      //Get the graph information from Cytoscape\n      var clusters = [[]];\n      if (this.options.clusters !== null && this.options.clusters !== undefined) clusters = this.options.clusters;\n      var nodes = state.nodes;\n      var edges = state.edges;\n\n      //Initialize CiSE elements\n      var ciseLayout = this.ciseLayout = new CiSELayout();\n      var graphManager = this.graphManager = ciseLayout.newGraphManager();\n      var root = this.root = graphManager.addRoot();\n\n      // Construct the GraphManager according to the graph from Cytoscape\n      this.idToLNode = ciseLayout.convertToClusteredGraph(nodes, edges, clusters);\n\n      //This method updates whether this graph is connected or not\n      root.updateConnected();\n      // This method calculates and returns the estimated size of this graph\n      root.calcEstimatedSize();\n      ciseLayout.calcNoOfChildrenForAllNodes();\n\n      ciseLayout.doStep1();\n      ciseLayout.doStep2();\n\n      root.updateBounds(true);\n      root.estimatedSize = Math.max(root.right - root.left, root.bottom - root.top);\n      ciseLayout.prepareCirclesForReversal();\n      ciseLayout.calcIdealEdgeLengths(false);\n\n      // ------------------------------------------\n      // The variables to maintain the spring steps\n      // ------------------------------------------\n      // Index is there to iterate over steps\n      this.initializerIndex = 0;\n\n      // If the whole algorithm is finished\n      this.isDone = false;\n\n      // If the current step is finished\n      this.isStepDone = false;\n\n      // when to change to next step\n      this.timeToSwitchNextStep = true;\n    }\n\n    // run this each iteraction\n\n  }, {\n    key: 'tick',\n    value: function tick() {\n      var _this2 = this;\n\n      // Getting References\n      var self = this;\n      var state = this.state;\n\n      // Update Each Node Locations\n      state.nodes.forEach(function (n) {\n        var s = _this2.getScratch(n);\n\n        var location = self.idToLNode[n.data('id')];\n        s.x = location.getCenterX();\n        s.y = location.getCenterY();\n      });\n\n      if (this.timeToSwitchNextStep) {\n        switch (this.initializerIndex) {\n          case 0:\n            this.ciseLayout.step5Init();\n            break;\n          case 1:\n            this.ciseLayout.step3Init();\n            break;\n          case 2:\n            this.ciseLayout.step5Init();\n            break;\n          case 3:\n            this.ciseLayout.step4Init();\n            break;\n          case 4:\n            this.ciseLayout.findAndMoveInnerNodes();\n            this.ciseLayout.calcIdealEdgeLengths(true);\n            this.ciseLayout.step5Init();\n            break;\n        }\n\n        this.initializerIndex++;\n        this.ciseLayout.iterations = 0;\n        this.ciseLayout.totalDisplacement = 1000;\n        this.timeToSwitchNextStep = false;\n      }\n\n      // Run one spring iteration\n      this.isStepDone = this.ciseLayout.runSpringEmbedderTick();\n\n      if (this.isStepDone && this.initializerIndex < 5) {\n        this.timeToSwitchNextStep = true;\n      }\n\n      if (this.isStepDone && this.timeToSwitchNextStep === false) {\n        this.isDone = true;\n      }\n\n      return this.isDone;\n    }\n\n    // run this function after the layout is done ticking\n\n  }, {\n    key: 'postrun',\n    value: function postrun() {}\n\n    // clean up any object refs that could prevent garbage collection, etc.\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      _get(Layout.prototype.__proto__ || Object.getPrototypeOf(Layout.prototype), 'destroy', this).call(this);\n\n      return this;\n    }\n  }]);\n\n  return Layout;\n}(ContinuousLayout);\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// general default options for force-directed layout\n\nmodule.exports = Object.freeze({\n  animate: false, // whether to show the layout as it's running; special 'end' value makes the layout animate like a discrete layout\n  refresh: 10, // number of ticks per frame; higher is faster but more jerky\n  maxIterations: 2500, // max iterations before the layout will bail out\n  maxSimulationTime: 5000, // max length in ms to run the layout\n  ungrabifyWhileSimulating: false, // so you can't drag nodes during layout\n  fit: true, // on every layout reposition of nodes, fit the viewport\n  padding: 30, // padding around the simulation\n  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\n  // layout event callbacks\n  ready: function ready() {}, // on layoutready\n  stop: function stop() {}, // on layoutstop\n\n  // positioning options\n  randomize: false, // use random node positions at beginning of layout\n\n  // infinite layout options\n  infinite: false // overrides all other options for a forces-all-the-time mode\n});\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\nA generic continuous layout class\n*/\n\nvar assign = __webpack_require__(2);\nvar defaults = __webpack_require__(17);\nvar makeBoundingBox = __webpack_require__(19);\n\nvar _require = __webpack_require__(20),\n    setInitialPositionState = _require.setInitialPositionState,\n    refreshPositions = _require.refreshPositions,\n    getNodePositionData = _require.getNodePositionData;\n\nvar _require2 = __webpack_require__(21),\n    multitick = _require2.multitick;\n\nvar Layout = function () {\n  function Layout(options) {\n    _classCallCheck(this, Layout);\n\n    var o = this.options = assign({}, defaults, options);\n\n    var s = this.state = assign({}, o, {\n      layout: this,\n      nodes: o.eles.nodes(),\n      edges: o.eles.edges(),\n      tickIndex: 0,\n      firstUpdate: true\n    });\n\n    s.animateEnd = o.animate && o.animate === 'end';\n    s.animateContinuously = o.animate && !s.animateEnd;\n  }\n\n  _createClass(Layout, [{\n    key: 'getScratch',\n    value: function getScratch(el) {\n      var name = this.state.name;\n      var scratch = el.scratch(name);\n\n      if (!scratch) {\n        scratch = {};\n\n        el.scratch(name, scratch);\n      }\n\n      return scratch;\n    }\n  }, {\n    key: 'run',\n    value: function run() {\n      var l = this;\n      var s = this.state;\n\n      s.tickIndex = 0;\n      s.firstUpdate = true;\n      s.startTime = Date.now();\n      s.running = true;\n\n      s.currentBoundingBox = makeBoundingBox(s.boundingBox, s.cy);\n\n      if (s.ready) {\n        l.one('ready', s.ready);\n      }\n      if (s.stop) {\n        l.one('stop', s.stop);\n      }\n\n      s.nodes.forEach(function (n) {\n        return setInitialPositionState(n, s);\n      });\n\n      l.prerun(s);\n\n      if (s.animateContinuously) {\n        var ungrabify = function ungrabify(node) {\n          if (!s.ungrabifyWhileSimulating) {\n            return;\n          }\n\n          var grabbable = getNodePositionData(node, s).grabbable = node.grabbable();\n\n          if (grabbable) {\n            node.ungrabify();\n          }\n        };\n\n        var regrabify = function regrabify(node) {\n          if (!s.ungrabifyWhileSimulating) {\n            return;\n          }\n\n          var grabbable = getNodePositionData(node, s).grabbable;\n\n          if (grabbable) {\n            node.grabify();\n          }\n        };\n\n        var updateGrabState = function updateGrabState(node) {\n          return getNodePositionData(node, s).grabbed = node.grabbed();\n        };\n\n        var onGrab = function onGrab(_ref) {\n          var target = _ref.target;\n\n          updateGrabState(target);\n        };\n\n        var onFree = onGrab;\n\n        var onDrag = function onDrag(_ref2) {\n          var target = _ref2.target;\n\n          var p = getNodePositionData(target, s);\n          var tp = target.position();\n\n          p.x = tp.x;\n          p.y = tp.y;\n        };\n\n        var listenToGrab = function listenToGrab(node) {\n          node.on('grab', onGrab);\n          node.on('free', onFree);\n          node.on('drag', onDrag);\n        };\n\n        var unlistenToGrab = function unlistenToGrab(node) {\n          node.removeListener('grab', onGrab);\n          node.removeListener('free', onFree);\n          node.removeListener('drag', onDrag);\n        };\n\n        var fit = function fit() {\n          if (s.fit && s.animateContinuously) {\n            s.cy.fit(s.padding);\n          }\n        };\n\n        var onNotDone = function onNotDone() {\n          refreshPositions(s.nodes, s);\n          fit();\n\n          requestAnimationFrame(_frame);\n        };\n\n        var _frame = function _frame() {\n          multitick(s, onNotDone, _onDone);\n        };\n\n        var _onDone = function _onDone() {\n          refreshPositions(s.nodes, s);\n          fit();\n\n          s.nodes.forEach(function (n) {\n            regrabify(n);\n            unlistenToGrab(n);\n          });\n\n          s.running = false;\n\n          l.emit('layoutstop');\n        };\n\n        l.emit('layoutstart');\n\n        s.nodes.forEach(function (n) {\n          ungrabify(n);\n          listenToGrab(n);\n        });\n\n        _frame(); // kick off\n      } else {\n        var done = false;\n        var _onNotDone = function _onNotDone() {};\n        var _onDone2 = function _onDone2() {\n          return done = true;\n        };\n\n        while (!done) {\n          multitick(s, _onNotDone, _onDone2);\n        }\n\n        s.eles.layoutPositions(this, s, function (node) {\n          var pd = getNodePositionData(node, s);\n\n          return { x: pd.x, y: pd.y };\n        });\n      }\n\n      l.postrun(s);\n\n      return this; // chaining\n    }\n  }, {\n    key: 'prerun',\n    value: function prerun() {}\n  }, {\n    key: 'postrun',\n    value: function postrun() {}\n  }, {\n    key: 'tick',\n    value: function tick() {}\n  }, {\n    key: 'stop',\n    value: function stop() {\n      this.state.running = false;\n\n      return this; // chaining\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      return this; // chaining\n    }\n  }]);\n\n  return Layout;\n}();\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (bb, cy) {\n  if (bb == null) {\n    bb = { x1: 0, y1: 0, w: cy.width(), h: cy.height() };\n  } else {\n    // copy\n    bb = { x1: bb.x1, x2: bb.x2, y1: bb.y1, y2: bb.y2, w: bb.w, h: bb.h };\n  }\n\n  if (bb.x2 == null) {\n    bb.x2 = bb.x1 + bb.w;\n  }\n  if (bb.w == null) {\n    bb.w = bb.x2 - bb.x1;\n  }\n  if (bb.y2 == null) {\n    bb.y2 = bb.y1 + bb.h;\n  }\n  if (bb.h == null) {\n    bb.h = bb.y2 - bb.y1;\n  }\n\n  return bb;\n};\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar assign = __webpack_require__(2);\n\nvar setInitialPositionState = function setInitialPositionState(node, state) {\n  var p = node.position();\n  var bb = state.currentBoundingBox;\n  var scratch = node.scratch(state.name);\n\n  if (scratch == null) {\n    scratch = {};\n\n    node.scratch(state.name, scratch);\n  }\n\n  assign(scratch, state.randomize ? {\n    x: bb.x1 + Math.round(Math.random() * bb.w),\n    y: bb.y1 + Math.round(Math.random() * bb.h)\n  } : {\n    x: p.x,\n    y: p.y\n  });\n\n  scratch.locked = node.locked();\n};\n\nvar getNodePositionData = function getNodePositionData(node, state) {\n  return node.scratch(state.name);\n};\n\nvar refreshPositions = function refreshPositions(nodes, state) {\n  nodes.positions(function (node) {\n    var scratch = node.scratch(state.name);\n\n    return {\n      x: scratch.x,\n      y: scratch.y\n    };\n  });\n};\n\nmodule.exports = { setInitialPositionState: setInitialPositionState, getNodePositionData: getNodePositionData, refreshPositions: refreshPositions };\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar nop = function nop() {};\n\nvar tick = function tick(state) {\n  var s = state;\n  var l = state.layout;\n\n  var tickIndicatesDone = l.tick(s);\n\n  if (s.firstUpdate) {\n    if (s.animateContinuously) {\n      // indicate the initial positions have been set\n      s.layout.emit('layoutready');\n    }\n    s.firstUpdate = false;\n  }\n\n  s.tickIndex++;\n\n  // || s.tickIndex >= s.maxIterations || duration >= s.maxSimulationTime -> This depends on # of nodes\n  return !s.infinite && tickIndicatesDone;\n};\n\nvar multitick = function multitick(state) {\n  var onNotDone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : nop;\n  var onDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : nop;\n\n  var done = false;\n  var s = state;\n\n  for (var i = 0; i < s.refresh; i++) {\n    done = !s.running || tick(s);\n\n    if (done) {\n      break;\n    }\n  }\n\n  if (!done) {\n    onNotDone();\n  } else {\n    onDone();\n  }\n};\n\nmodule.exports = { tick: tick, multitick: multitick };\n\n/***/ })\n/******/ ]);\n});","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"layoutBase\"] = factory();\n\telse\n\t\troot[\"layoutBase\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 26);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LayoutConstants() {}\n\n/**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */\nLayoutConstants.QUALITY = 1;\n\n/**\r\n * Default parameters\r\n */\nLayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\nLayoutConstants.DEFAULT_INCREMENTAL = false;\nLayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\nLayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\nLayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\nLayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n\n// -----------------------------------------------------------------------------\n// Section: General other constants\n// -----------------------------------------------------------------------------\n/*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */\nLayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n\n/*\r\n * Whether to consider labels in node dimensions or not\r\n */\nLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_SIZE = 40;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n\n/*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */\nLayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n\n/*\r\n * Minimum length that an edge should take during layout\r\n */\nLayoutConstants.MIN_EDGE_LENGTH = 1;\n\n/*\r\n * World boundaries that layout operates on\r\n */\nLayoutConstants.WORLD_BOUNDARY = 1000000;\n\n/*\r\n * World boundaries that random positioning can be performed with\r\n */\nLayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n\n/*\r\n * Coordinates of the world center\r\n */\nLayoutConstants.WORLD_CENTER_X = 1200;\nLayoutConstants.WORLD_CENTER_Y = 900;\n\nmodule.exports = LayoutConstants;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar IGeometry = __webpack_require__(8);\nvar IMath = __webpack_require__(9);\n\nfunction LEdge(source, target, vEdge) {\n  LGraphObject.call(this, vEdge);\n\n  this.isOverlapingSourceAndTarget = false;\n  this.vGraphObject = vEdge;\n  this.bendpoints = [];\n  this.source = source;\n  this.target = target;\n}\n\nLEdge.prototype = Object.create(LGraphObject.prototype);\n\nfor (var prop in LGraphObject) {\n  LEdge[prop] = LGraphObject[prop];\n}\n\nLEdge.prototype.getSource = function () {\n  return this.source;\n};\n\nLEdge.prototype.getTarget = function () {\n  return this.target;\n};\n\nLEdge.prototype.isInterGraph = function () {\n  return this.isInterGraph;\n};\n\nLEdge.prototype.getLength = function () {\n  return this.length;\n};\n\nLEdge.prototype.isOverlapingSourceAndTarget = function () {\n  return this.isOverlapingSourceAndTarget;\n};\n\nLEdge.prototype.getBendpoints = function () {\n  return this.bendpoints;\n};\n\nLEdge.prototype.getLca = function () {\n  return this.lca;\n};\n\nLEdge.prototype.getSourceInLca = function () {\n  return this.sourceInLca;\n};\n\nLEdge.prototype.getTargetInLca = function () {\n  return this.targetInLca;\n};\n\nLEdge.prototype.getOtherEnd = function (node) {\n  if (this.source === node) {\n    return this.target;\n  } else if (this.target === node) {\n    return this.source;\n  } else {\n    throw \"Node is not incident with this edge\";\n  }\n};\n\nLEdge.prototype.getOtherEndInGraph = function (node, graph) {\n  var otherEnd = this.getOtherEnd(node);\n  var root = graph.getGraphManager().getRoot();\n\n  while (true) {\n    if (otherEnd.getOwner() == graph) {\n      return otherEnd;\n    }\n\n    if (otherEnd.getOwner() == root) {\n      break;\n    }\n\n    otherEnd = otherEnd.getOwner().getParent();\n  }\n\n  return null;\n};\n\nLEdge.prototype.updateLength = function () {\n  var clipPointCoordinates = new Array(4);\n\n  this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n\n  if (!this.isOverlapingSourceAndTarget) {\n    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n    if (Math.abs(this.lengthX) < 1.0) {\n      this.lengthX = IMath.sign(this.lengthX);\n    }\n\n    if (Math.abs(this.lengthY) < 1.0) {\n      this.lengthY = IMath.sign(this.lengthY);\n    }\n\n    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n  }\n};\n\nLEdge.prototype.updateLengthSimple = function () {\n  this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n  this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n  if (Math.abs(this.lengthX) < 1.0) {\n    this.lengthX = IMath.sign(this.lengthX);\n  }\n\n  if (Math.abs(this.lengthY) < 1.0) {\n    this.lengthY = IMath.sign(this.lengthY);\n  }\n\n  this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n};\n\nmodule.exports = LEdge;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LGraphObject(vGraphObject) {\n  this.vGraphObject = vGraphObject;\n}\n\nmodule.exports = LGraphObject;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar Integer = __webpack_require__(10);\nvar RectangleD = __webpack_require__(13);\nvar LayoutConstants = __webpack_require__(0);\nvar RandomSeed = __webpack_require__(16);\nvar PointD = __webpack_require__(4);\n\nfunction LNode(gm, loc, size, vNode) {\n  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n  if (size == null && vNode == null) {\n    vNode = loc;\n  }\n\n  LGraphObject.call(this, vNode);\n\n  //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n  if (gm.graphManager != null) gm = gm.graphManager;\n\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.inclusionTreeDepth = Integer.MAX_VALUE;\n  this.vGraphObject = vNode;\n  this.edges = [];\n  this.graphManager = gm;\n\n  if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\n}\n\nLNode.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LNode[prop] = LGraphObject[prop];\n}\n\nLNode.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLNode.prototype.getChild = function () {\n  return this.child;\n};\n\nLNode.prototype.getOwner = function () {\n  //  if (this.owner != null) {\n  //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n  //      throw \"assert failed\";\n  //    }\n  //  }\n\n  return this.owner;\n};\n\nLNode.prototype.getWidth = function () {\n  return this.rect.width;\n};\n\nLNode.prototype.setWidth = function (width) {\n  this.rect.width = width;\n};\n\nLNode.prototype.getHeight = function () {\n  return this.rect.height;\n};\n\nLNode.prototype.setHeight = function (height) {\n  this.rect.height = height;\n};\n\nLNode.prototype.getCenterX = function () {\n  return this.rect.x + this.rect.width / 2;\n};\n\nLNode.prototype.getCenterY = function () {\n  return this.rect.y + this.rect.height / 2;\n};\n\nLNode.prototype.getCenter = function () {\n  return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n};\n\nLNode.prototype.getLocation = function () {\n  return new PointD(this.rect.x, this.rect.y);\n};\n\nLNode.prototype.getRect = function () {\n  return this.rect;\n};\n\nLNode.prototype.getDiagonal = function () {\n  return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n};\n\n/**\n * This method returns half the diagonal length of this node.\n */\nLNode.prototype.getHalfTheDiagonal = function () {\n  return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n};\n\nLNode.prototype.setRect = function (upperLeft, dimension) {\n  this.rect.x = upperLeft.x;\n  this.rect.y = upperLeft.y;\n  this.rect.width = dimension.width;\n  this.rect.height = dimension.height;\n};\n\nLNode.prototype.setCenter = function (cx, cy) {\n  this.rect.x = cx - this.rect.width / 2;\n  this.rect.y = cy - this.rect.height / 2;\n};\n\nLNode.prototype.setLocation = function (x, y) {\n  this.rect.x = x;\n  this.rect.y = y;\n};\n\nLNode.prototype.moveBy = function (dx, dy) {\n  this.rect.x += dx;\n  this.rect.y += dy;\n};\n\nLNode.prototype.getEdgeListToNode = function (to) {\n  var edgeList = [];\n  var edge;\n  var self = this;\n\n  self.edges.forEach(function (edge) {\n\n    if (edge.target == to) {\n      if (edge.source != self) throw \"Incorrect edge source!\";\n\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getEdgesBetween = function (other) {\n  var edgeList = [];\n  var edge;\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n\n    if (edge.target == other || edge.source == other) {\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getNeighborsList = function () {\n  var neighbors = new Set();\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (edge.source == self) {\n      neighbors.add(edge.target);\n    } else {\n      if (edge.target != self) {\n        throw \"Incorrect incidency!\";\n      }\n\n      neighbors.add(edge.source);\n    }\n  });\n\n  return neighbors;\n};\n\nLNode.prototype.withChildren = function () {\n  var withNeighborsList = new Set();\n  var childNode;\n  var children;\n\n  withNeighborsList.add(this);\n\n  if (this.child != null) {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n      children = childNode.withChildren();\n      children.forEach(function (node) {\n        withNeighborsList.add(node);\n      });\n    }\n  }\n\n  return withNeighborsList;\n};\n\nLNode.prototype.getNoOfChildren = function () {\n  var noOfChildren = 0;\n  var childNode;\n\n  if (this.child == null) {\n    noOfChildren = 1;\n  } else {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n\n      noOfChildren += childNode.getNoOfChildren();\n    }\n  }\n\n  if (noOfChildren == 0) {\n    noOfChildren = 1;\n  }\n  return noOfChildren;\n};\n\nLNode.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLNode.prototype.calcEstimatedSize = function () {\n  if (this.child == null) {\n    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n  } else {\n    this.estimatedSize = this.child.calcEstimatedSize();\n    this.rect.width = this.estimatedSize;\n    this.rect.height = this.estimatedSize;\n\n    return this.estimatedSize;\n  }\n};\n\nLNode.prototype.scatter = function () {\n  var randomCenterX;\n  var randomCenterY;\n\n  var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n\n  var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n\n  this.rect.x = randomCenterX;\n  this.rect.y = randomCenterY;\n};\n\nLNode.prototype.updateBounds = function () {\n  if (this.getChild() == null) {\n    throw \"assert failed\";\n  }\n  if (this.getChild().getNodes().length != 0) {\n    // wrap the children nodes by re-arranging the boundaries\n    var childGraph = this.getChild();\n    childGraph.updateBounds(true);\n\n    this.rect.x = childGraph.getLeft();\n    this.rect.y = childGraph.getTop();\n\n    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n\n    // Update compound bounds considering its label properties    \n    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = childGraph.getRight() - childGraph.getLeft();\n      var height = childGraph.getBottom() - childGraph.getTop();\n\n      if (this.labelWidth > width) {\n        this.rect.x -= (this.labelWidth - width) / 2;\n        this.setWidth(this.labelWidth);\n      }\n\n      if (this.labelHeight > height) {\n        if (this.labelPos == \"center\") {\n          this.rect.y -= (this.labelHeight - height) / 2;\n        } else if (this.labelPos == \"top\") {\n          this.rect.y -= this.labelHeight - height;\n        }\n        this.setHeight(this.labelHeight);\n      }\n    }\n  }\n};\n\nLNode.prototype.getInclusionTreeDepth = function () {\n  if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.inclusionTreeDepth;\n};\n\nLNode.prototype.transform = function (trans) {\n  var left = this.rect.x;\n\n  if (left > LayoutConstants.WORLD_BOUNDARY) {\n    left = LayoutConstants.WORLD_BOUNDARY;\n  } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n    left = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var top = this.rect.y;\n\n  if (top > LayoutConstants.WORLD_BOUNDARY) {\n    top = LayoutConstants.WORLD_BOUNDARY;\n  } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n    top = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var leftTop = new PointD(left, top);\n  var vLeftTop = trans.inverseTransformPoint(leftTop);\n\n  this.setLocation(vLeftTop.x, vLeftTop.y);\n};\n\nLNode.prototype.getLeft = function () {\n  return this.rect.x;\n};\n\nLNode.prototype.getRight = function () {\n  return this.rect.x + this.rect.width;\n};\n\nLNode.prototype.getTop = function () {\n  return this.rect.y;\n};\n\nLNode.prototype.getBottom = function () {\n  return this.rect.y + this.rect.height;\n};\n\nLNode.prototype.getParent = function () {\n  if (this.owner == null) {\n    return null;\n  }\n\n  return this.owner.getParent();\n};\n\nmodule.exports = LNode;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction PointD(x, y) {\n  if (x == null && y == null) {\n    this.x = 0;\n    this.y = 0;\n  } else {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nPointD.prototype.getX = function () {\n  return this.x;\n};\n\nPointD.prototype.getY = function () {\n  return this.y;\n};\n\nPointD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nPointD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nPointD.prototype.getDifference = function (pt) {\n  return new DimensionD(this.x - pt.x, this.y - pt.y);\n};\n\nPointD.prototype.getCopy = function () {\n  return new PointD(this.x, this.y);\n};\n\nPointD.prototype.translate = function (dim) {\n  this.x += dim.width;\n  this.y += dim.height;\n  return this;\n};\n\nmodule.exports = PointD;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar Integer = __webpack_require__(10);\nvar LayoutConstants = __webpack_require__(0);\nvar LGraphManager = __webpack_require__(6);\nvar LNode = __webpack_require__(3);\nvar LEdge = __webpack_require__(1);\nvar RectangleD = __webpack_require__(13);\nvar Point = __webpack_require__(12);\nvar LinkedList = __webpack_require__(11);\n\nfunction LGraph(parent, obj2, vGraph) {\n  LGraphObject.call(this, vGraph);\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n  this.edges = [];\n  this.nodes = [];\n  this.isConnected = false;\n  this.parent = parent;\n\n  if (obj2 != null && obj2 instanceof LGraphManager) {\n    this.graphManager = obj2;\n  } else if (obj2 != null && obj2 instanceof Layout) {\n    this.graphManager = obj2.graphManager;\n  }\n}\n\nLGraph.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LGraph[prop] = LGraphObject[prop];\n}\n\nLGraph.prototype.getNodes = function () {\n  return this.nodes;\n};\n\nLGraph.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLGraph.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLGraph.prototype.getParent = function () {\n  return this.parent;\n};\n\nLGraph.prototype.getLeft = function () {\n  return this.left;\n};\n\nLGraph.prototype.getRight = function () {\n  return this.right;\n};\n\nLGraph.prototype.getTop = function () {\n  return this.top;\n};\n\nLGraph.prototype.getBottom = function () {\n  return this.bottom;\n};\n\nLGraph.prototype.isConnected = function () {\n  return this.isConnected;\n};\n\nLGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n  if (sourceNode == null && targetNode == null) {\n    var newNode = obj1;\n    if (this.graphManager == null) {\n      throw \"Graph has no graph mgr!\";\n    }\n    if (this.getNodes().indexOf(newNode) > -1) {\n      throw \"Node already in graph!\";\n    }\n    newNode.owner = this;\n    this.getNodes().push(newNode);\n\n    return newNode;\n  } else {\n    var newEdge = obj1;\n    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n      throw \"Source or target not in graph!\";\n    }\n\n    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n      throw \"Both owners must be this graph!\";\n    }\n\n    if (sourceNode.owner != targetNode.owner) {\n      return null;\n    }\n\n    // set source and target\n    newEdge.source = sourceNode;\n    newEdge.target = targetNode;\n\n    // set as intra-graph edge\n    newEdge.isInterGraph = false;\n\n    // add to graph edge list\n    this.getEdges().push(newEdge);\n\n    // add to incidency lists\n    sourceNode.edges.push(newEdge);\n\n    if (targetNode != sourceNode) {\n      targetNode.edges.push(newEdge);\n    }\n\n    return newEdge;\n  }\n};\n\nLGraph.prototype.remove = function (obj) {\n  var node = obj;\n  if (obj instanceof LNode) {\n    if (node == null) {\n      throw \"Node is null!\";\n    }\n    if (!(node.owner != null && node.owner == this)) {\n      throw \"Owner graph is invalid!\";\n    }\n    if (this.graphManager == null) {\n      throw \"Owner graph manager is invalid!\";\n    }\n    // remove incident edges first (make a copy to do it safely)\n    var edgesToBeRemoved = node.edges.slice();\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n\n      if (edge.isInterGraph) {\n        this.graphManager.remove(edge);\n      } else {\n        edge.source.owner.remove(edge);\n      }\n    }\n\n    // now the node itself\n    var index = this.nodes.indexOf(node);\n    if (index == -1) {\n      throw \"Node not in owner node list!\";\n    }\n\n    this.nodes.splice(index, 1);\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n      throw \"Source and/or target owner is invalid!\";\n    }\n\n    var sourceIndex = edge.source.edges.indexOf(edge);\n    var targetIndex = edge.target.edges.indexOf(edge);\n    if (!(sourceIndex > -1 && targetIndex > -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    edge.source.edges.splice(sourceIndex, 1);\n\n    if (edge.target != edge.source) {\n      edge.target.edges.splice(targetIndex, 1);\n    }\n\n    var index = edge.source.owner.getEdges().indexOf(edge);\n    if (index == -1) {\n      throw \"Not in owner's edge list!\";\n    }\n\n    edge.source.owner.getEdges().splice(index, 1);\n  }\n};\n\nLGraph.prototype.updateLeftTop = function () {\n  var top = Integer.MAX_VALUE;\n  var left = Integer.MAX_VALUE;\n  var nodeTop;\n  var nodeLeft;\n  var margin;\n\n  var nodes = this.getNodes();\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeTop = lNode.getTop();\n    nodeLeft = lNode.getLeft();\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n  }\n\n  // Do we have any nodes in this graph?\n  if (top == Integer.MAX_VALUE) {\n    return null;\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = left - margin;\n  this.top = top - margin;\n\n  // Apply the margins and return the result\n  return new Point(this.left, this.top);\n};\n\nLGraph.prototype.updateBounds = function (recursive) {\n  // calculate bounds\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n  var margin;\n\n  var nodes = this.nodes;\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n\n    if (recursive && lNode.child != null) {\n      lNode.updateBounds();\n    }\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n  if (left == Integer.MAX_VALUE) {\n    this.left = this.parent.getLeft();\n    this.right = this.parent.getRight();\n    this.top = this.parent.getTop();\n    this.bottom = this.parent.getBottom();\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = boundingRect.x - margin;\n  this.right = boundingRect.x + boundingRect.width + margin;\n  this.top = boundingRect.y - margin;\n  this.bottom = boundingRect.y + boundingRect.height + margin;\n};\n\nLGraph.calculateBounds = function (nodes) {\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n  return boundingRect;\n};\n\nLGraph.prototype.getInclusionTreeDepth = function () {\n  if (this == this.graphManager.getRoot()) {\n    return 1;\n  } else {\n    return this.parent.getInclusionTreeDepth();\n  }\n};\n\nLGraph.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLGraph.prototype.calcEstimatedSize = function () {\n  var size = 0;\n  var nodes = this.nodes;\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    size += lNode.calcEstimatedSize();\n  }\n\n  if (size == 0) {\n    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n  } else {\n    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n  }\n\n  return this.estimatedSize;\n};\n\nLGraph.prototype.updateConnected = function () {\n  var self = this;\n  if (this.nodes.length == 0) {\n    this.isConnected = true;\n    return;\n  }\n\n  var queue = new LinkedList();\n  var visited = new Set();\n  var currentNode = this.nodes[0];\n  var neighborEdges;\n  var currentNeighbor;\n  var childrenOfNode = currentNode.withChildren();\n  childrenOfNode.forEach(function (node) {\n    queue.push(node);\n    visited.add(node);\n  });\n\n  while (queue.length !== 0) {\n    currentNode = queue.shift();\n\n    // Traverse all neighbors of this node\n    neighborEdges = currentNode.getEdges();\n    var size = neighborEdges.length;\n    for (var i = 0; i < size; i++) {\n      var neighborEdge = neighborEdges[i];\n      currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n\n      // Add unvisited neighbors to the list to visit\n      if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n        var childrenOfNeighbor = currentNeighbor.withChildren();\n\n        childrenOfNeighbor.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n        });\n      }\n    }\n  }\n\n  this.isConnected = false;\n\n  if (visited.size >= this.nodes.length) {\n    var noOfVisitedInThisGraph = 0;\n\n    visited.forEach(function (visitedNode) {\n      if (visitedNode.owner == self) {\n        noOfVisitedInThisGraph++;\n      }\n    });\n\n    if (noOfVisitedInThisGraph == this.nodes.length) {\n      this.isConnected = true;\n    }\n  }\n};\n\nmodule.exports = LGraph;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraph;\nvar LEdge = __webpack_require__(1);\n\nfunction LGraphManager(layout) {\n  LGraph = __webpack_require__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n  this.layout = layout;\n\n  this.graphs = [];\n  this.edges = [];\n}\n\nLGraphManager.prototype.addRoot = function () {\n  var ngraph = this.layout.newGraph();\n  var nnode = this.layout.newNode(null);\n  var root = this.add(ngraph, nnode);\n  this.setRootGraph(root);\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\n  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n  if (newEdge == null && sourceNode == null && targetNode == null) {\n    if (newGraph == null) {\n      throw \"Graph is null!\";\n    }\n    if (parentNode == null) {\n      throw \"Parent node is null!\";\n    }\n    if (this.graphs.indexOf(newGraph) > -1) {\n      throw \"Graph already in this graph mgr!\";\n    }\n\n    this.graphs.push(newGraph);\n\n    if (newGraph.parent != null) {\n      throw \"Already has a parent!\";\n    }\n    if (parentNode.child != null) {\n      throw \"Already has a child!\";\n    }\n\n    newGraph.parent = parentNode;\n    parentNode.child = newGraph;\n\n    return newGraph;\n  } else {\n    //change the order of the parameters\n    targetNode = newEdge;\n    sourceNode = parentNode;\n    newEdge = newGraph;\n    var sourceGraph = sourceNode.getOwner();\n    var targetGraph = targetNode.getOwner();\n\n    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n      throw \"Source not in this graph mgr!\";\n    }\n    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n      throw \"Target not in this graph mgr!\";\n    }\n\n    if (sourceGraph == targetGraph) {\n      newEdge.isInterGraph = false;\n      return sourceGraph.add(newEdge, sourceNode, targetNode);\n    } else {\n      newEdge.isInterGraph = true;\n\n      // set source and target\n      newEdge.source = sourceNode;\n      newEdge.target = targetNode;\n\n      // add edge to inter-graph edge list\n      if (this.edges.indexOf(newEdge) > -1) {\n        throw \"Edge already in inter-graph edge list!\";\n      }\n\n      this.edges.push(newEdge);\n\n      // add edge to source and target incidency lists\n      if (!(newEdge.source != null && newEdge.target != null)) {\n        throw \"Edge source and/or target is null!\";\n      }\n\n      if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n        throw \"Edge already in source and/or target incidency list!\";\n      }\n\n      newEdge.source.edges.push(newEdge);\n      newEdge.target.edges.push(newEdge);\n\n      return newEdge;\n    }\n  }\n};\n\nLGraphManager.prototype.remove = function (lObj) {\n  if (lObj instanceof LGraph) {\n    var graph = lObj;\n    if (graph.getGraphManager() != this) {\n      throw \"Graph not in this graph mgr\";\n    }\n    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n      throw \"Invalid parent node!\";\n    }\n\n    // first the edges (make a copy to do it safely)\n    var edgesToBeRemoved = [];\n\n    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n      graph.remove(edge);\n    }\n\n    // then the nodes (make a copy to do it safely)\n    var nodesToBeRemoved = [];\n\n    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n\n    var node;\n    s = nodesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      node = nodesToBeRemoved[i];\n      graph.remove(node);\n    }\n\n    // check if graph is the root\n    if (graph == this.rootGraph) {\n      this.setRootGraph(null);\n    }\n\n    // now remove the graph itself\n    var index = this.graphs.indexOf(graph);\n    this.graphs.splice(index, 1);\n\n    // also reset the parent of the graph\n    graph.parent = null;\n  } else if (lObj instanceof LEdge) {\n    edge = lObj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!edge.isInterGraph) {\n      throw \"Not an inter-graph edge!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n\n    // remove edge from source and target nodes' incidency lists\n\n    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    var index = edge.source.edges.indexOf(edge);\n    edge.source.edges.splice(index, 1);\n    index = edge.target.edges.indexOf(edge);\n    edge.target.edges.splice(index, 1);\n\n    // remove edge from owner graph manager's inter-graph edge list\n\n    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n      throw \"Edge owner graph or owner graph manager is null!\";\n    }\n    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n      throw \"Not in owner graph manager's edge list!\";\n    }\n\n    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n    edge.source.owner.getGraphManager().edges.splice(index, 1);\n  }\n};\n\nLGraphManager.prototype.updateBounds = function () {\n  this.rootGraph.updateBounds(true);\n};\n\nLGraphManager.prototype.getGraphs = function () {\n  return this.graphs;\n};\n\nLGraphManager.prototype.getAllNodes = function () {\n  if (this.allNodes == null) {\n    var nodeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < s; i++) {\n      nodeList = nodeList.concat(graphs[i].getNodes());\n    }\n    this.allNodes = nodeList;\n  }\n  return this.allNodes;\n};\n\nLGraphManager.prototype.resetAllNodes = function () {\n  this.allNodes = null;\n};\n\nLGraphManager.prototype.resetAllEdges = function () {\n  this.allEdges = null;\n};\n\nLGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\n  this.allNodesToApplyGravitation = null;\n};\n\nLGraphManager.prototype.getAllEdges = function () {\n  if (this.allEdges == null) {\n    var edgeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < graphs.length; i++) {\n      edgeList = edgeList.concat(graphs[i].getEdges());\n    }\n\n    edgeList = edgeList.concat(this.edges);\n\n    this.allEdges = edgeList;\n  }\n  return this.allEdges;\n};\n\nLGraphManager.prototype.getAllNodesToApplyGravitation = function () {\n  return this.allNodesToApplyGravitation;\n};\n\nLGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\n  if (this.allNodesToApplyGravitation != null) {\n    throw \"assert failed\";\n  }\n\n  this.allNodesToApplyGravitation = nodeList;\n};\n\nLGraphManager.prototype.getRoot = function () {\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.setRootGraph = function (graph) {\n  if (graph.getGraphManager() != this) {\n    throw \"Root not in this graph mgr!\";\n  }\n\n  this.rootGraph = graph;\n  // root graph must have a root node associated with it for convenience\n  if (graph.parent == null) {\n    graph.parent = this.layout.newNode(\"Root node\");\n  }\n};\n\nLGraphManager.prototype.getLayout = function () {\n  return this.layout;\n};\n\nLGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\n  if (!(firstNode != null && secondNode != null)) {\n    throw \"assert failed\";\n  }\n\n  if (firstNode == secondNode) {\n    return true;\n  }\n  // Is second node an ancestor of the first one?\n  var ownerGraph = firstNode.getOwner();\n  var parentNode;\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == secondNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n  // Is first node an ancestor of the second one?\n  ownerGraph = secondNode.getOwner();\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == firstNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n\n  return false;\n};\n\nLGraphManager.prototype.calcLowestCommonAncestors = function () {\n  var edge;\n  var sourceNode;\n  var targetNode;\n  var sourceAncestorGraph;\n  var targetAncestorGraph;\n\n  var edges = this.getAllEdges();\n  var s = edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = edges[i];\n\n    sourceNode = edge.source;\n    targetNode = edge.target;\n    edge.lca = null;\n    edge.sourceInLca = sourceNode;\n    edge.targetInLca = targetNode;\n\n    if (sourceNode == targetNode) {\n      edge.lca = sourceNode.getOwner();\n      continue;\n    }\n\n    sourceAncestorGraph = sourceNode.getOwner();\n\n    while (edge.lca == null) {\n      edge.targetInLca = targetNode;\n      targetAncestorGraph = targetNode.getOwner();\n\n      while (edge.lca == null) {\n        if (targetAncestorGraph == sourceAncestorGraph) {\n          edge.lca = targetAncestorGraph;\n          break;\n        }\n\n        if (targetAncestorGraph == this.rootGraph) {\n          break;\n        }\n\n        if (edge.lca != null) {\n          throw \"assert failed\";\n        }\n        edge.targetInLca = targetAncestorGraph.getParent();\n        targetAncestorGraph = edge.targetInLca.getOwner();\n      }\n\n      if (sourceAncestorGraph == this.rootGraph) {\n        break;\n      }\n\n      if (edge.lca == null) {\n        edge.sourceInLca = sourceAncestorGraph.getParent();\n        sourceAncestorGraph = edge.sourceInLca.getOwner();\n      }\n    }\n\n    if (edge.lca == null) {\n      throw \"assert failed\";\n    }\n  }\n};\n\nLGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\n  if (firstNode == secondNode) {\n    return firstNode.getOwner();\n  }\n  var firstOwnerGraph = firstNode.getOwner();\n\n  do {\n    if (firstOwnerGraph == null) {\n      break;\n    }\n    var secondOwnerGraph = secondNode.getOwner();\n\n    do {\n      if (secondOwnerGraph == null) {\n        break;\n      }\n\n      if (secondOwnerGraph == firstOwnerGraph) {\n        return secondOwnerGraph;\n      }\n      secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n    } while (true);\n\n    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n  } while (true);\n\n  return firstOwnerGraph;\n};\n\nLGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n  if (graph == null && depth == null) {\n    graph = this.rootGraph;\n    depth = 1;\n  }\n  var node;\n\n  var nodes = graph.getNodes();\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    node = nodes[i];\n    node.inclusionTreeDepth = depth;\n\n    if (node.child != null) {\n      this.calcInclusionTreeDepths(node.child, depth + 1);\n    }\n  }\n};\n\nLGraphManager.prototype.includesInvalidEdge = function () {\n  var edge;\n\n  var s = this.edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = this.edges[i];\n\n    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports = LGraphManager;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __webpack_require__(0);\n\nfunction FDLayoutConstants() {}\n\n//FDLayoutConstants inherits static props in LayoutConstants\nfor (var prop in LayoutConstants) {\n  FDLayoutConstants[prop] = LayoutConstants[prop];\n}\n\nFDLayoutConstants.MAX_ITERATIONS = 2500;\n\nFDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\nFDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\nFDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\nFDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\nFDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\nFDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\nFDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\nFDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\nFDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\nFDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\nFDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\nFDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\nFDLayoutConstants.MIN_EDGE_LENGTH = 1;\nFDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n\nmodule.exports = FDLayoutConstants;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar Point = __webpack_require__(12);\n\nfunction IGeometry() {}\n\n/**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */\nIGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\n  if (!rectA.intersects(rectB)) {\n    throw \"assert failed\";\n  }\n\n  var directions = new Array(2);\n\n  this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n\n  overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n  overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n\n  // update the overlapping amounts for the following cases:\n  if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */\n    overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n  } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */\n    overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n  }\n  if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */\n    overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n  } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */\n    overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n  }\n\n  // find slope of the line passes two centers\n  var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n  // if centers are overlapped\n  if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n    // assume the slope is 1 (45 degree)\n    slope = 1.0;\n  }\n\n  var moveByY = slope * overlapAmount[0];\n  var moveByX = overlapAmount[1] / slope;\n  if (overlapAmount[0] < moveByX) {\n    moveByX = overlapAmount[0];\n  } else {\n    moveByY = overlapAmount[1];\n  }\n  // return half the amount so that if each rectangle is moved by these\n  // amounts in opposite directions, overlap will be resolved\n  overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n  overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n};\n\n/**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */\nIGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\n  if (rectA.getCenterX() < rectB.getCenterX()) {\n    directions[0] = -1;\n  } else {\n    directions[0] = 1;\n  }\n\n  if (rectA.getCenterY() < rectB.getCenterY()) {\n    directions[1] = -1;\n  } else {\n    directions[1] = 1;\n  }\n};\n\n/**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */\nIGeometry.getIntersection2 = function (rectA, rectB, result) {\n  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n  var p1x = rectA.getCenterX();\n  var p1y = rectA.getCenterY();\n  var p2x = rectB.getCenterX();\n  var p2y = rectB.getCenterY();\n\n  //if two rectangles intersect, then clipping points are centers\n  if (rectA.intersects(rectB)) {\n    result[0] = p1x;\n    result[1] = p1y;\n    result[2] = p2x;\n    result[3] = p2y;\n    return true;\n  }\n  //variables for rectA\n  var topLeftAx = rectA.getX();\n  var topLeftAy = rectA.getY();\n  var topRightAx = rectA.getRight();\n  var bottomLeftAx = rectA.getX();\n  var bottomLeftAy = rectA.getBottom();\n  var bottomRightAx = rectA.getRight();\n  var halfWidthA = rectA.getWidthHalf();\n  var halfHeightA = rectA.getHeightHalf();\n  //variables for rectB\n  var topLeftBx = rectB.getX();\n  var topLeftBy = rectB.getY();\n  var topRightBx = rectB.getRight();\n  var bottomLeftBx = rectB.getX();\n  var bottomLeftBy = rectB.getBottom();\n  var bottomRightBx = rectB.getRight();\n  var halfWidthB = rectB.getWidthHalf();\n  var halfHeightB = rectB.getHeightHalf();\n\n  //flag whether clipping points are found\n  var clipPointAFound = false;\n  var clipPointBFound = false;\n\n  // line is vertical\n  if (p1x === p2x) {\n    if (p1y > p2y) {\n      result[0] = p1x;\n      result[1] = topLeftAy;\n      result[2] = p2x;\n      result[3] = bottomLeftBy;\n      return false;\n    } else if (p1y < p2y) {\n      result[0] = p1x;\n      result[1] = bottomLeftAy;\n      result[2] = p2x;\n      result[3] = topLeftBy;\n      return false;\n    } else {\n      //not line, return null;\n    }\n  }\n  // line is horizontal\n  else if (p1y === p2y) {\n      if (p1x > p2x) {\n        result[0] = topLeftAx;\n        result[1] = p1y;\n        result[2] = topRightBx;\n        result[3] = p2y;\n        return false;\n      } else if (p1x < p2x) {\n        result[0] = topRightAx;\n        result[1] = p1y;\n        result[2] = topLeftBx;\n        result[3] = p2y;\n        return false;\n      } else {\n        //not valid line, return null;\n      }\n    } else {\n      //slopes of rectA's and rectB's diagonals\n      var slopeA = rectA.height / rectA.width;\n      var slopeB = rectB.height / rectB.width;\n\n      //slope of line between center of rectA and center of rectB\n      var slopePrime = (p2y - p1y) / (p2x - p1x);\n      var cardinalDirectionA = void 0;\n      var cardinalDirectionB = void 0;\n      var tempPointAx = void 0;\n      var tempPointAy = void 0;\n      var tempPointBx = void 0;\n      var tempPointBy = void 0;\n\n      //determine whether clipping point is the corner of nodeA\n      if (-slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = bottomLeftAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = topRightAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        }\n      } else if (slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = topLeftAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = bottomRightAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        }\n      }\n\n      //determine whether clipping point is the corner of nodeB\n      if (-slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = bottomLeftBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = topRightBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        }\n      } else if (slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = topLeftBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = bottomRightBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        }\n      }\n\n      //if both clipping points are corners\n      if (clipPointAFound && clipPointBFound) {\n        return false;\n      }\n\n      //determine Cardinal Direction of rectangles\n      if (p1x > p2x) {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n        }\n      } else {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n        }\n      }\n      //calculate clipping Point if it is not found before\n      if (!clipPointAFound) {\n        switch (cardinalDirectionA) {\n          case 1:\n            tempPointAy = topLeftAy;\n            tempPointAx = p1x + -halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 2:\n            tempPointAx = bottomRightAx;\n            tempPointAy = p1y + halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 3:\n            tempPointAy = bottomLeftAy;\n            tempPointAx = p1x + halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 4:\n            tempPointAx = bottomLeftAx;\n            tempPointAy = p1y + -halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n        }\n      }\n      if (!clipPointBFound) {\n        switch (cardinalDirectionB) {\n          case 1:\n            tempPointBy = topLeftBy;\n            tempPointBx = p2x + -halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 2:\n            tempPointBx = bottomRightBx;\n            tempPointBy = p2y + halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 3:\n            tempPointBy = bottomLeftBy;\n            tempPointBx = p2x + halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 4:\n            tempPointBx = bottomLeftBx;\n            tempPointBy = p2y + -halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n        }\n      }\n    }\n  return false;\n};\n\n/**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */\nIGeometry.getCardinalDirection = function (slope, slopePrime, line) {\n  if (slope > slopePrime) {\n    return line;\n  } else {\n    return 1 + line % 4;\n  }\n};\n\n/**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */\nIGeometry.getIntersection = function (s1, s2, f1, f2) {\n  if (f2 == null) {\n    return this.getIntersection2(s1, s2, f1);\n  }\n\n  var x1 = s1.x;\n  var y1 = s1.y;\n  var x2 = s2.x;\n  var y2 = s2.y;\n  var x3 = f1.x;\n  var y3 = f1.y;\n  var x4 = f2.x;\n  var y4 = f2.y;\n  var x = void 0,\n      y = void 0; // intersection point\n  var a1 = void 0,\n      a2 = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      c1 = void 0,\n      c2 = void 0; // coefficients of line eqns.\n  var denom = void 0;\n\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n\n  denom = a1 * b2 - a2 * b1;\n\n  if (denom === 0) {\n    return null;\n  }\n\n  x = (b1 * c2 - b2 * c1) / denom;\n  y = (a2 * c1 - a1 * c2) / denom;\n\n  return new Point(x, y);\n};\n\n/**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */\nIGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\n  var C_angle = void 0;\n\n  if (Cx !== Nx) {\n    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n\n    if (Nx < Cx) {\n      C_angle += Math.PI;\n    } else if (Ny < Cy) {\n      C_angle += this.TWO_PI;\n    }\n  } else if (Ny < Cy) {\n    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n  } else {\n    C_angle = this.HALF_PI; // 90 degrees\n  }\n\n  return C_angle;\n};\n\n/**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */\nIGeometry.doIntersect = function (p1, p2, p3, p4) {\n  var a = p1.x;\n  var b = p1.y;\n  var c = p2.x;\n  var d = p2.y;\n  var p = p3.x;\n  var q = p3.y;\n  var r = p4.x;\n  var s = p4.y;\n  var det = (c - a) * (s - q) - (r - p) * (d - b);\n\n  if (det === 0) {\n    return false;\n  } else {\n    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Class Constants\n// -----------------------------------------------------------------------------\n/**\n * Some useful pre-calculated constants\n */\nIGeometry.HALF_PI = 0.5 * Math.PI;\nIGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\nIGeometry.TWO_PI = 2.0 * Math.PI;\nIGeometry.THREE_PI = 3.0 * Math.PI;\n\nmodule.exports = IGeometry;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction IMath() {}\n\n/**\n * This method returns the sign of the input value.\n */\nIMath.sign = function (value) {\n  if (value > 0) {\n    return 1;\n  } else if (value < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nIMath.floor = function (value) {\n  return value < 0 ? Math.ceil(value) : Math.floor(value);\n};\n\nIMath.ceil = function (value) {\n  return value < 0 ? Math.floor(value) : Math.ceil(value);\n};\n\nmodule.exports = IMath;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Integer() {}\n\nInteger.MAX_VALUE = 2147483647;\nInteger.MIN_VALUE = -2147483648;\n\nmodule.exports = Integer;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar nodeFrom = function nodeFrom(value) {\n  return { value: value, next: null, prev: null };\n};\n\nvar add = function add(prev, node, next, list) {\n  if (prev !== null) {\n    prev.next = node;\n  } else {\n    list.head = node;\n  }\n\n  if (next !== null) {\n    next.prev = node;\n  } else {\n    list.tail = node;\n  }\n\n  node.prev = prev;\n  node.next = next;\n\n  list.length++;\n\n  return node;\n};\n\nvar _remove = function _remove(node, list) {\n  var prev = node.prev,\n      next = node.next;\n\n\n  if (prev !== null) {\n    prev.next = next;\n  } else {\n    list.head = next;\n  }\n\n  if (next !== null) {\n    next.prev = prev;\n  } else {\n    list.tail = prev;\n  }\n\n  node.prev = node.next = null;\n\n  list.length--;\n\n  return node;\n};\n\nvar LinkedList = function () {\n  function LinkedList(vals) {\n    var _this = this;\n\n    _classCallCheck(this, LinkedList);\n\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n\n    if (vals != null) {\n      vals.forEach(function (v) {\n        return _this.push(v);\n      });\n    }\n  }\n\n  _createClass(LinkedList, [{\n    key: \"size\",\n    value: function size() {\n      return this.length;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(val, otherNode) {\n      return add(otherNode.prev, nodeFrom(val), otherNode, this);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(val, otherNode) {\n      return add(otherNode, nodeFrom(val), otherNode.next, this);\n    }\n  }, {\n    key: \"insertNodeBefore\",\n    value: function insertNodeBefore(newNode, otherNode) {\n      return add(otherNode.prev, newNode, otherNode, this);\n    }\n  }, {\n    key: \"insertNodeAfter\",\n    value: function insertNodeAfter(newNode, otherNode) {\n      return add(otherNode, newNode, otherNode.next, this);\n    }\n  }, {\n    key: \"push\",\n    value: function push(val) {\n      return add(this.tail, nodeFrom(val), null, this);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(val) {\n      return add(null, nodeFrom(val), this.head, this);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      return _remove(node, this);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return _remove(this.tail, this).value;\n    }\n  }, {\n    key: \"popNode\",\n    value: function popNode() {\n      return _remove(this.tail, this);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      return _remove(this.head, this).value;\n    }\n  }, {\n    key: \"shiftNode\",\n    value: function shiftNode() {\n      return _remove(this.head, this);\n    }\n  }, {\n    key: \"get_object_at\",\n    value: function get_object_at(index) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        return current.value;\n      }\n    }\n  }, {\n    key: \"set_object_at\",\n    value: function set_object_at(index, value) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        current.value = value;\n      }\n    }\n  }]);\n\n  return LinkedList;\n}();\n\nmodule.exports = LinkedList;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */\nfunction Point(x, y, p) {\n  this.x = null;\n  this.y = null;\n  if (x == null && y == null && p == null) {\n    this.x = 0;\n    this.y = 0;\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    this.x = x;\n    this.y = y;\n  } else if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.x = p.x;\n    this.y = p.y;\n  }\n}\n\nPoint.prototype.getX = function () {\n  return this.x;\n};\n\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nPoint.prototype.getLocation = function () {\n  return new Point(this.x, this.y);\n};\n\nPoint.prototype.setLocation = function (x, y, p) {\n  if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.setLocation(p.x, p.y);\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    //if both parameters are integer just move (x,y) location\n    if (parseInt(x) == x && parseInt(y) == y) {\n      this.move(x, y);\n    } else {\n      this.x = Math.floor(x + 0.5);\n      this.y = Math.floor(y + 0.5);\n    }\n  }\n};\n\nPoint.prototype.move = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\n\nPoint.prototype.translate = function (dx, dy) {\n  this.x += dx;\n  this.y += dy;\n};\n\nPoint.prototype.equals = function (obj) {\n  if (obj.constructor.name == \"Point\") {\n    var pt = obj;\n    return this.x == pt.x && this.y == pt.y;\n  }\n  return this == obj;\n};\n\nPoint.prototype.toString = function () {\n  return new Point().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n};\n\nmodule.exports = Point;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RectangleD(x, y, width, height) {\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n\n  if (x != null && y != null && width != null && height != null) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nRectangleD.prototype.getX = function () {\n  return this.x;\n};\n\nRectangleD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nRectangleD.prototype.getY = function () {\n  return this.y;\n};\n\nRectangleD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nRectangleD.prototype.getWidth = function () {\n  return this.width;\n};\n\nRectangleD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nRectangleD.prototype.getHeight = function () {\n  return this.height;\n};\n\nRectangleD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nRectangleD.prototype.getRight = function () {\n  return this.x + this.width;\n};\n\nRectangleD.prototype.getBottom = function () {\n  return this.y + this.height;\n};\n\nRectangleD.prototype.intersects = function (a) {\n  if (this.getRight() < a.x) {\n    return false;\n  }\n\n  if (this.getBottom() < a.y) {\n    return false;\n  }\n\n  if (a.getRight() < this.x) {\n    return false;\n  }\n\n  if (a.getBottom() < this.y) {\n    return false;\n  }\n\n  return true;\n};\n\nRectangleD.prototype.getCenterX = function () {\n  return this.x + this.width / 2;\n};\n\nRectangleD.prototype.getMinX = function () {\n  return this.getX();\n};\n\nRectangleD.prototype.getMaxX = function () {\n  return this.getX() + this.width;\n};\n\nRectangleD.prototype.getCenterY = function () {\n  return this.y + this.height / 2;\n};\n\nRectangleD.prototype.getMinY = function () {\n  return this.getY();\n};\n\nRectangleD.prototype.getMaxY = function () {\n  return this.getY() + this.height;\n};\n\nRectangleD.prototype.getWidthHalf = function () {\n  return this.width / 2;\n};\n\nRectangleD.prototype.getHeightHalf = function () {\n  return this.height / 2;\n};\n\nmodule.exports = RectangleD;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction UniqueIDGeneretor() {}\n\nUniqueIDGeneretor.lastID = 0;\n\nUniqueIDGeneretor.createID = function (obj) {\n  if (UniqueIDGeneretor.isPrimitive(obj)) {\n    return obj;\n  }\n  if (obj.uniqueID != null) {\n    return obj.uniqueID;\n  }\n  obj.uniqueID = UniqueIDGeneretor.getString();\n  UniqueIDGeneretor.lastID++;\n  return obj.uniqueID;\n};\n\nUniqueIDGeneretor.getString = function (id) {\n  if (id == null) id = UniqueIDGeneretor.lastID;\n  return \"Object#\" + id + \"\";\n};\n\nUniqueIDGeneretor.isPrimitive = function (arg) {\n  var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n  return arg == null || type != \"object\" && type != \"function\";\n};\n\nmodule.exports = UniqueIDGeneretor;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar LayoutConstants = __webpack_require__(0);\nvar LGraphManager = __webpack_require__(6);\nvar LNode = __webpack_require__(3);\nvar LEdge = __webpack_require__(1);\nvar LGraph = __webpack_require__(5);\nvar PointD = __webpack_require__(4);\nvar Transform = __webpack_require__(17);\nvar Emitter = __webpack_require__(27);\n\nfunction Layout(isRemoteUse) {\n  Emitter.call(this);\n\n  //Layout Quality: 0:draft, 1:default, 2:proof\n  this.layoutQuality = LayoutConstants.QUALITY;\n  //Whether layout should create bendpoints as needed or not\n  this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  //Whether layout should be incremental or not\n  this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n  //Whether we animate from before to after layout node positions\n  this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n  //Whether we animate the layout process or not\n  this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n  //Number iterations that should be done between two successive animations\n  this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n  /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */\n  this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */\n  this.edgeToDummyNodes = new Map();\n  this.graphManager = new LGraphManager(this);\n  this.isLayoutFinished = false;\n  this.isSubLayout = false;\n  this.isRemoteUse = false;\n\n  if (isRemoteUse != null) {\n    this.isRemoteUse = isRemoteUse;\n  }\n}\n\nLayout.RANDOM_SEED = 1;\n\nLayout.prototype = Object.create(Emitter.prototype);\n\nLayout.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLayout.prototype.getAllNodes = function () {\n  return this.graphManager.getAllNodes();\n};\n\nLayout.prototype.getAllEdges = function () {\n  return this.graphManager.getAllEdges();\n};\n\nLayout.prototype.getAllNodesToApplyGravitation = function () {\n  return this.graphManager.getAllNodesToApplyGravitation();\n};\n\nLayout.prototype.newGraphManager = function () {\n  var gm = new LGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nLayout.prototype.newGraph = function (vGraph) {\n  return new LGraph(null, this.graphManager, vGraph);\n};\n\nLayout.prototype.newNode = function (vNode) {\n  return new LNode(this.graphManager, vNode);\n};\n\nLayout.prototype.newEdge = function (vEdge) {\n  return new LEdge(null, null, vEdge);\n};\n\nLayout.prototype.checkLayoutSuccess = function () {\n  return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n};\n\nLayout.prototype.runLayout = function () {\n  this.isLayoutFinished = false;\n\n  if (this.tilingPreLayout) {\n    this.tilingPreLayout();\n  }\n\n  this.initParameters();\n  var isLayoutSuccessfull;\n\n  if (this.checkLayoutSuccess()) {\n    isLayoutSuccessfull = false;\n  } else {\n    isLayoutSuccessfull = this.layout();\n  }\n\n  if (LayoutConstants.ANIMATE === 'during') {\n    // If this is a 'during' layout animation. Layout is not finished yet. \n    // We need to perform these in index.js when layout is really finished.\n    return false;\n  }\n\n  if (isLayoutSuccessfull) {\n    if (!this.isSubLayout) {\n      this.doPostLayout();\n    }\n  }\n\n  if (this.tilingPostLayout) {\n    this.tilingPostLayout();\n  }\n\n  this.isLayoutFinished = true;\n\n  return isLayoutSuccessfull;\n};\n\n/**\r\n * This method performs the operations required after layout.\r\n */\nLayout.prototype.doPostLayout = function () {\n  //assert !isSubLayout : \"Should not be called on sub-layout!\";\n  // Propagate geometric changes to v-level objects\n  if (!this.incremental) {\n    this.transform();\n  }\n  this.update();\n};\n\n/**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */\nLayout.prototype.update2 = function () {\n  // update bend points\n  if (this.createBendsAsNeeded) {\n    this.createBendpointsFromDummyNodes();\n\n    // reset all edges, since the topology has changed\n    this.graphManager.resetAllEdges();\n  }\n\n  // perform edge, node and root updates if layout is not called\n  // remotely\n  if (!this.isRemoteUse) {\n    // update all edges\n    var edge;\n    var allEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < allEdges.length; i++) {\n      edge = allEdges[i];\n      //      this.update(edge);\n    }\n\n    // recursively update nodes\n    var node;\n    var nodes = this.graphManager.getRoot().getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      //      this.update(node);\n    }\n\n    // update root graph\n    this.update(this.graphManager.getRoot());\n  }\n};\n\nLayout.prototype.update = function (obj) {\n  if (obj == null) {\n    this.update2();\n  } else if (obj instanceof LNode) {\n    var node = obj;\n    if (node.getChild() != null) {\n      // since node is compound, recursively update child nodes\n      var nodes = node.getChild().getNodes();\n      for (var i = 0; i < nodes.length; i++) {\n        update(nodes[i]);\n      }\n    }\n\n    // if the l-level node is associated with a v-level graph object,\n    // then it is assumed that the v-level node implements the\n    // interface Updatable.\n    if (node.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vNode = node.vGraphObject;\n\n      // call the update method of the interface\n      vNode.update(node);\n    }\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    // if the l-level edge is associated with a v-level graph object,\n    // then it is assumed that the v-level edge implements the\n    // interface Updatable.\n\n    if (edge.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vEdge = edge.vGraphObject;\n\n      // call the update method of the interface\n      vEdge.update(edge);\n    }\n  } else if (obj instanceof LGraph) {\n    var graph = obj;\n    // if the l-level graph is associated with a v-level graph object,\n    // then it is assumed that the v-level object implements the\n    // interface Updatable.\n\n    if (graph.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vGraph = graph.vGraphObject;\n\n      // call the update method of the interface\n      vGraph.update(graph);\n    }\n  }\n};\n\n/**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */\nLayout.prototype.initParameters = function () {\n  if (!this.isSubLayout) {\n    this.layoutQuality = LayoutConstants.QUALITY;\n    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  }\n\n  if (this.animationDuringLayout) {\n    this.animationOnLayout = false;\n  }\n};\n\nLayout.prototype.transform = function (newLeftTop) {\n  if (newLeftTop == undefined) {\n    this.transform(new PointD(0, 0));\n  } else {\n    // create a transformation object (from Eclipse to layout). When an\n    // inverse transform is applied, we get upper-left coordinate of the\n    // drawing or the root graph at given input coordinate (some margins\n    // already included in calculation of left-top).\n\n    var trans = new Transform();\n    var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n    if (leftTop != null) {\n      trans.setWorldOrgX(newLeftTop.x);\n      trans.setWorldOrgY(newLeftTop.y);\n\n      trans.setDeviceOrgX(leftTop.x);\n      trans.setDeviceOrgY(leftTop.y);\n\n      var nodes = this.getAllNodes();\n      var node;\n\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.transform(trans);\n      }\n    }\n  }\n};\n\nLayout.prototype.positionNodesRandomly = function (graph) {\n\n  if (graph == undefined) {\n    //assert !this.incremental;\n    this.positionNodesRandomly(this.getGraphManager().getRoot());\n    this.getGraphManager().getRoot().updateBounds(true);\n  } else {\n    var lNode;\n    var childGraph;\n\n    var nodes = graph.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      lNode = nodes[i];\n      childGraph = lNode.getChild();\n\n      if (childGraph == null) {\n        lNode.scatter();\n      } else if (childGraph.getNodes().length == 0) {\n        lNode.scatter();\n      } else {\n        this.positionNodesRandomly(childGraph);\n        lNode.updateBounds();\n      }\n    }\n  }\n};\n\n/**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */\nLayout.prototype.getFlatForest = function () {\n  var flatForest = [];\n  var isForest = true;\n\n  // Quick reference for all nodes in the graph manager associated with\n  // this layout. The list should not be changed.\n  var allNodes = this.graphManager.getRoot().getNodes();\n\n  // First be sure that the graph is flat\n  var isFlat = true;\n\n  for (var i = 0; i < allNodes.length; i++) {\n    if (allNodes[i].getChild() != null) {\n      isFlat = false;\n    }\n  }\n\n  // Return empty forest if the graph is not flat.\n  if (!isFlat) {\n    return flatForest;\n  }\n\n  // Run BFS for each component of the graph.\n\n  var visited = new Set();\n  var toBeVisited = [];\n  var parents = new Map();\n  var unProcessedNodes = [];\n\n  unProcessedNodes = unProcessedNodes.concat(allNodes);\n\n  // Each iteration of this loop finds a component of the graph and\n  // decides whether it is a tree or not. If it is a tree, adds it to the\n  // forest and continued with the next component.\n\n  while (unProcessedNodes.length > 0 && isForest) {\n    toBeVisited.push(unProcessedNodes[0]);\n\n    // Start the BFS. Each iteration of this loop visits a node in a\n    // BFS manner.\n    while (toBeVisited.length > 0 && isForest) {\n      //pool operation\n      var currentNode = toBeVisited[0];\n      toBeVisited.splice(0, 1);\n      visited.add(currentNode);\n\n      // Traverse all neighbors of this node\n      var neighborEdges = currentNode.getEdges();\n\n      for (var i = 0; i < neighborEdges.length; i++) {\n        var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n\n        // If BFS is not growing from this neighbor.\n        if (parents.get(currentNode) != currentNeighbor) {\n          // We haven't previously visited this neighbor.\n          if (!visited.has(currentNeighbor)) {\n            toBeVisited.push(currentNeighbor);\n            parents.set(currentNeighbor, currentNode);\n          }\n          // Since we have previously visited this neighbor and\n          // this neighbor is not parent of currentNode, given\n          // graph contains a component that is not tree, hence\n          // it is not a forest.\n          else {\n              isForest = false;\n              break;\n            }\n        }\n      }\n    }\n\n    // The graph contains a component that is not a tree. Empty\n    // previously found trees. The method will end.\n    if (!isForest) {\n      flatForest = [];\n    }\n    // Save currently visited nodes as a tree in our forest. Reset\n    // visited and parents lists. Continue with the next component of\n    // the graph, if any.\n    else {\n        var temp = [].concat(_toConsumableArray(visited));\n        flatForest.push(temp);\n        //flatForest = flatForest.concat(temp);\n        //unProcessedNodes.removeAll(visited);\n        for (var i = 0; i < temp.length; i++) {\n          var value = temp[i];\n          var index = unProcessedNodes.indexOf(value);\n          if (index > -1) {\n            unProcessedNodes.splice(index, 1);\n          }\n        }\n        visited = new Set();\n        parents = new Map();\n      }\n  }\n\n  return flatForest;\n};\n\n/**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */\nLayout.prototype.createDummyNodesForBendpoints = function (edge) {\n  var dummyNodes = [];\n  var prev = edge.source;\n\n  var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n  for (var i = 0; i < edge.bendpoints.length; i++) {\n    // create new dummy node\n    var dummyNode = this.newNode(null);\n    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n\n    graph.add(dummyNode);\n\n    // create new dummy edge between prev and dummy node\n    var dummyEdge = this.newEdge(null);\n    this.graphManager.add(dummyEdge, prev, dummyNode);\n\n    dummyNodes.add(dummyNode);\n    prev = dummyNode;\n  }\n\n  var dummyEdge = this.newEdge(null);\n  this.graphManager.add(dummyEdge, prev, edge.target);\n\n  this.edgeToDummyNodes.set(edge, dummyNodes);\n\n  // remove real edge from graph manager if it is inter-graph\n  if (edge.isInterGraph()) {\n    this.graphManager.remove(edge);\n  }\n  // else, remove the edge from the current graph\n  else {\n      graph.remove(edge);\n    }\n\n  return dummyNodes;\n};\n\n/**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */\nLayout.prototype.createBendpointsFromDummyNodes = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n\n  for (var k = 0; k < edges.length; k++) {\n    var lEdge = edges[k];\n\n    if (lEdge.bendpoints.length > 0) {\n      var path = this.edgeToDummyNodes.get(lEdge);\n\n      for (var i = 0; i < path.length; i++) {\n        var dummyNode = path[i];\n        var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n\n        // update bendpoint's location according to dummy node\n        var ebp = lEdge.bendpoints.get(i);\n        ebp.x = p.x;\n        ebp.y = p.y;\n\n        // remove the dummy node, dummy edges incident with this\n        // dummy node is also removed (within the remove method)\n        dummyNode.getOwner().remove(dummyNode);\n      }\n\n      // add the real edge to graph\n      this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n    }\n  }\n};\n\nLayout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n  if (minDiv != undefined && maxMul != undefined) {\n    var value = defaultValue;\n\n    if (sliderValue <= 50) {\n      var minValue = defaultValue / minDiv;\n      value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n    } else {\n      var maxValue = defaultValue * maxMul;\n      value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n    }\n\n    return value;\n  } else {\n    var a, b;\n\n    if (sliderValue <= 50) {\n      a = 9.0 * defaultValue / 500.0;\n      b = defaultValue / 10.0;\n    } else {\n      a = 9.0 * defaultValue / 50.0;\n      b = -8 * defaultValue;\n    }\n\n    return a * sliderValue + b;\n  }\n};\n\n/**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */\nLayout.findCenterOfTree = function (nodes) {\n  var list = [];\n  list = list.concat(nodes);\n\n  var removedNodes = [];\n  var remainingDegrees = new Map();\n  var foundCenter = false;\n  var centerNode = null;\n\n  if (list.length == 1 || list.length == 2) {\n    foundCenter = true;\n    centerNode = list[0];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var node = list[i];\n    var degree = node.getNeighborsList().size;\n    remainingDegrees.set(node, node.getNeighborsList().size);\n\n    if (degree == 1) {\n      removedNodes.push(node);\n    }\n  }\n\n  var tempList = [];\n  tempList = tempList.concat(removedNodes);\n\n  while (!foundCenter) {\n    var tempList2 = [];\n    tempList2 = tempList2.concat(tempList);\n    tempList = [];\n\n    for (var i = 0; i < list.length; i++) {\n      var node = list[i];\n\n      var index = list.indexOf(node);\n      if (index >= 0) {\n        list.splice(index, 1);\n      }\n\n      var neighbours = node.getNeighborsList();\n\n      neighbours.forEach(function (neighbour) {\n        if (removedNodes.indexOf(neighbour) < 0) {\n          var otherDegree = remainingDegrees.get(neighbour);\n          var newDegree = otherDegree - 1;\n\n          if (newDegree == 1) {\n            tempList.push(neighbour);\n          }\n\n          remainingDegrees.set(neighbour, newDegree);\n        }\n      });\n    }\n\n    removedNodes = removedNodes.concat(tempList);\n\n    if (list.length == 1 || list.length == 2) {\n      foundCenter = true;\n      centerNode = list[0];\n    }\n  }\n\n  return centerNode;\n};\n\n/**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */\nLayout.prototype.setGraphManager = function (gm) {\n  this.graphManager = gm;\n};\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RandomSeed() {}\n// adapted from: https://stackoverflow.com/a/19303725\nRandomSeed.seed = 1;\nRandomSeed.x = 0;\n\nRandomSeed.nextDouble = function () {\n  RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n  return RandomSeed.x - Math.floor(RandomSeed.x);\n};\n\nmodule.exports = RandomSeed;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar PointD = __webpack_require__(4);\n\nfunction Transform(x, y) {\n  this.lworldOrgX = 0.0;\n  this.lworldOrgY = 0.0;\n  this.ldeviceOrgX = 0.0;\n  this.ldeviceOrgY = 0.0;\n  this.lworldExtX = 1.0;\n  this.lworldExtY = 1.0;\n  this.ldeviceExtX = 1.0;\n  this.ldeviceExtY = 1.0;\n}\n\nTransform.prototype.getWorldOrgX = function () {\n  return this.lworldOrgX;\n};\n\nTransform.prototype.setWorldOrgX = function (wox) {\n  this.lworldOrgX = wox;\n};\n\nTransform.prototype.getWorldOrgY = function () {\n  return this.lworldOrgY;\n};\n\nTransform.prototype.setWorldOrgY = function (woy) {\n  this.lworldOrgY = woy;\n};\n\nTransform.prototype.getWorldExtX = function () {\n  return this.lworldExtX;\n};\n\nTransform.prototype.setWorldExtX = function (wex) {\n  this.lworldExtX = wex;\n};\n\nTransform.prototype.getWorldExtY = function () {\n  return this.lworldExtY;\n};\n\nTransform.prototype.setWorldExtY = function (wey) {\n  this.lworldExtY = wey;\n};\n\n/* Device related */\n\nTransform.prototype.getDeviceOrgX = function () {\n  return this.ldeviceOrgX;\n};\n\nTransform.prototype.setDeviceOrgX = function (dox) {\n  this.ldeviceOrgX = dox;\n};\n\nTransform.prototype.getDeviceOrgY = function () {\n  return this.ldeviceOrgY;\n};\n\nTransform.prototype.setDeviceOrgY = function (doy) {\n  this.ldeviceOrgY = doy;\n};\n\nTransform.prototype.getDeviceExtX = function () {\n  return this.ldeviceExtX;\n};\n\nTransform.prototype.setDeviceExtX = function (dex) {\n  this.ldeviceExtX = dex;\n};\n\nTransform.prototype.getDeviceExtY = function () {\n  return this.ldeviceExtY;\n};\n\nTransform.prototype.setDeviceExtY = function (dey) {\n  this.ldeviceExtY = dey;\n};\n\nTransform.prototype.transformX = function (x) {\n  var xDevice = 0.0;\n  var worldExtX = this.lworldExtX;\n  if (worldExtX != 0.0) {\n    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n  }\n\n  return xDevice;\n};\n\nTransform.prototype.transformY = function (y) {\n  var yDevice = 0.0;\n  var worldExtY = this.lworldExtY;\n  if (worldExtY != 0.0) {\n    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n  }\n\n  return yDevice;\n};\n\nTransform.prototype.inverseTransformX = function (x) {\n  var xWorld = 0.0;\n  var deviceExtX = this.ldeviceExtX;\n  if (deviceExtX != 0.0) {\n    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n  }\n\n  return xWorld;\n};\n\nTransform.prototype.inverseTransformY = function (y) {\n  var yWorld = 0.0;\n  var deviceExtY = this.ldeviceExtY;\n  if (deviceExtY != 0.0) {\n    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n  }\n  return yWorld;\n};\n\nTransform.prototype.inverseTransformPoint = function (inPoint) {\n  var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n  return outPoint;\n};\n\nmodule.exports = Transform;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Layout = __webpack_require__(15);\nvar FDLayoutConstants = __webpack_require__(7);\nvar LayoutConstants = __webpack_require__(0);\nvar IGeometry = __webpack_require__(8);\nvar IMath = __webpack_require__(9);\n\nfunction FDLayout() {\n  Layout.call(this);\n\n  this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n  this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n  this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n  this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n  this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n  this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n  this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n  this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.totalDisplacement = 0.0;\n  this.oldTotalDisplacement = 0.0;\n  this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n}\n\nFDLayout.prototype = Object.create(Layout.prototype);\n\nfor (var prop in Layout) {\n  FDLayout[prop] = Layout[prop];\n}\n\nFDLayout.prototype.initParameters = function () {\n  Layout.prototype.initParameters.call(this, arguments);\n\n  this.totalIterations = 0;\n  this.notAnimatedIterations = 0;\n\n  this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n\n  this.grid = [];\n};\n\nFDLayout.prototype.calcIdealEdgeLengths = function () {\n  var edge;\n  var lcaDepth;\n  var source;\n  var target;\n  var sizeOfSourceInLca;\n  var sizeOfTargetInLca;\n\n  var allEdges = this.getGraphManager().getAllEdges();\n  for (var i = 0; i < allEdges.length; i++) {\n    edge = allEdges[i];\n\n    edge.idealLength = this.idealEdgeLength;\n\n    if (edge.isInterGraph) {\n      source = edge.getSource();\n      target = edge.getTarget();\n\n      sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n      sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n      if (this.useSmartIdealEdgeLengthCalculation) {\n        edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n      }\n\n      lcaDepth = edge.getLca().getInclusionTreeDepth();\n\n      edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n    }\n  }\n};\n\nFDLayout.prototype.initSpringEmbedder = function () {\n\n  var s = this.getAllNodes().length;\n  if (this.incremental) {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    }\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n  } else {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    } else {\n      this.coolingFactor = 1.0;\n    }\n    this.initialCoolingFactor = this.coolingFactor;\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n  }\n\n  this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n\n  this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n\n  this.repulsionRange = this.calcRepulsionRange();\n};\n\nFDLayout.prototype.calcSpringForces = function () {\n  var lEdges = this.getAllEdges();\n  var edge;\n\n  for (var i = 0; i < lEdges.length; i++) {\n    edge = lEdges[i];\n\n    this.calcSpringForce(edge, edge.idealLength);\n  }\n};\n\nFDLayout.prototype.calcRepulsionForces = function () {\n  var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var i, j;\n  var nodeA, nodeB;\n  var lNodes = this.getAllNodes();\n  var processedNodeSet;\n\n  if (this.useFRGridVariant) {\n    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n      this.updateGrid();\n    }\n\n    processedNodeSet = new Set();\n\n    // calculate repulsion forces between each nodes and its surrounding\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n      this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n      processedNodeSet.add(nodeA);\n    }\n  } else {\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n\n      for (j = i + 1; j < lNodes.length; j++) {\n        nodeB = lNodes[j];\n\n        // If both nodes are not members of the same graph, skip.\n        if (nodeA.getOwner() != nodeB.getOwner()) {\n          continue;\n        }\n\n        this.calcRepulsionForce(nodeA, nodeB);\n      }\n    }\n  }\n};\n\nFDLayout.prototype.calcGravitationalForces = function () {\n  var node;\n  var lNodes = this.getAllNodesToApplyGravitation();\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    this.calcGravitationalForce(node);\n  }\n};\n\nFDLayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\nFDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n  var sourceNode = edge.getSource();\n  var targetNode = edge.getTarget();\n\n  var length;\n  var springForce;\n  var springForceX;\n  var springForceY;\n\n  // Update edge length\n  if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n    edge.updateLengthSimple();\n  } else {\n    edge.updateLength();\n\n    if (edge.isOverlapingSourceAndTarget) {\n      return;\n    }\n  }\n\n  length = edge.getLength();\n\n  if (length == 0) return;\n\n  // Calculate spring forces\n  springForce = this.springConstant * (length - idealLength);\n\n  // Project force onto x and y axes\n  springForceX = springForce * (edge.lengthX / length);\n  springForceY = springForce * (edge.lengthY / length);\n\n  // Apply forces on the end nodes\n  sourceNode.springForceX += springForceX;\n  sourceNode.springForceY += springForceY;\n  targetNode.springForceX -= springForceX;\n  targetNode.springForceY -= springForceY;\n};\n\nFDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n  var rectA = nodeA.getRect();\n  var rectB = nodeB.getRect();\n  var overlapAmount = new Array(2);\n  var clipPoints = new Array(4);\n  var distanceX;\n  var distanceY;\n  var distanceSquared;\n  var distance;\n  var repulsionForce;\n  var repulsionForceX;\n  var repulsionForceY;\n\n  if (rectA.intersects(rectB)) // two nodes overlap\n    {\n      // calculate separation amount in x and y directions\n      IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n\n      repulsionForceX = 2 * overlapAmount[0];\n      repulsionForceY = 2 * overlapAmount[1];\n\n      var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n\n      // Apply forces on the two nodes\n      nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n      nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n      nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n      nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n    } else // no overlap\n    {\n      // calculate distance\n\n      if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\n        {\n          distanceX = rectB.getCenterX() - rectA.getCenterX();\n          distanceY = rectB.getCenterY() - rectA.getCenterY();\n        } else // use clipping points\n        {\n          IGeometry.getIntersection(rectA, rectB, clipPoints);\n\n          distanceX = clipPoints[2] - clipPoints[0];\n          distanceY = clipPoints[3] - clipPoints[1];\n        }\n\n      // No repulsion range. FR grid variant should take care of this.\n      if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      distanceSquared = distanceX * distanceX + distanceY * distanceY;\n      distance = Math.sqrt(distanceSquared);\n\n      repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n\n      // Project force onto x and y axes\n      repulsionForceX = repulsionForce * distanceX / distance;\n      repulsionForceY = repulsionForce * distanceY / distance;\n\n      // Apply forces on the two nodes    \n      nodeA.repulsionForceX -= repulsionForceX;\n      nodeA.repulsionForceY -= repulsionForceY;\n      nodeB.repulsionForceX += repulsionForceX;\n      nodeB.repulsionForceY += repulsionForceY;\n    }\n};\n\nFDLayout.prototype.calcGravitationalForce = function (node) {\n  var ownerGraph;\n  var ownerCenterX;\n  var ownerCenterY;\n  var distanceX;\n  var distanceY;\n  var absDistanceX;\n  var absDistanceY;\n  var estimatedSize;\n  ownerGraph = node.getOwner();\n\n  ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n  ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n  distanceX = node.getCenterX() - ownerCenterX;\n  distanceY = node.getCenterY() - ownerCenterY;\n  absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n  absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n\n  if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX;\n        node.gravitationForceY = -this.gravityConstant * distanceY;\n      }\n    } else // inside a compound\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n      }\n    }\n};\n\nFDLayout.prototype.isConverged = function () {\n  var converged;\n  var oscilating = false;\n\n  if (this.totalIterations > this.maxIterations / 3) {\n    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n  }\n\n  converged = this.totalDisplacement < this.totalDisplacementThreshold;\n\n  this.oldTotalDisplacement = this.totalDisplacement;\n\n  return converged || oscilating;\n};\n\nFDLayout.prototype.animate = function () {\n  if (this.animationDuringLayout && !this.isSubLayout) {\n    if (this.notAnimatedIterations == this.animationPeriod) {\n      this.update();\n      this.notAnimatedIterations = 0;\n    } else {\n      this.notAnimatedIterations++;\n    }\n  }\n};\n\n//This method calculates the number of children (weight) for all nodes\nFDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\n  var node;\n  var allNodes = this.graphManager.getAllNodes();\n\n  for (var i = 0; i < allNodes.length; i++) {\n    node = allNodes[i];\n    node.noOfChildren = node.getNoOfChildren();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: FR-Grid Variant Repulsion Force Calculation\n// -----------------------------------------------------------------------------\n\nFDLayout.prototype.calcGrid = function (graph) {\n\n  var sizeX = 0;\n  var sizeY = 0;\n\n  sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n  sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n\n  var grid = new Array(sizeX);\n\n  for (var i = 0; i < sizeX; i++) {\n    grid[i] = new Array(sizeY);\n  }\n\n  for (var i = 0; i < sizeX; i++) {\n    for (var j = 0; j < sizeY; j++) {\n      grid[i][j] = new Array();\n    }\n  }\n\n  return grid;\n};\n\nFDLayout.prototype.addNodeToGrid = function (v, left, top) {\n\n  var startX = 0;\n  var finishX = 0;\n  var startY = 0;\n  var finishY = 0;\n\n  startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n  finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n  startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n  finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n\n  for (var i = startX; i <= finishX; i++) {\n    for (var j = startY; j <= finishY; j++) {\n      this.grid[i][j].push(v);\n      v.setGridCoordinates(startX, finishX, startY, finishY);\n    }\n  }\n};\n\nFDLayout.prototype.updateGrid = function () {\n  var i;\n  var nodeA;\n  var lNodes = this.getAllNodes();\n\n  this.grid = this.calcGrid(this.graphManager.getRoot());\n\n  // put all nodes to proper grid cells\n  for (i = 0; i < lNodes.length; i++) {\n    nodeA = lNodes[i];\n    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n  }\n};\n\nFDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n\n  if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n    var surrounding = new Set();\n    nodeA.surrounding = new Array();\n    var nodeB;\n    var grid = this.grid;\n\n    for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n      for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n        if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n          for (var k = 0; k < grid[i][j].length; k++) {\n            nodeB = grid[i][j][k];\n\n            // If both nodes are not members of the same graph, \n            // or both nodes are the same, skip.\n            if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n              continue;\n            }\n\n            // check if the repulsion force between\n            // nodeA and nodeB has already been calculated\n            if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n              var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n              var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n\n              // if the distance between nodeA and nodeB \n              // is less then calculation range\n              if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                //then add nodeB to surrounding of nodeA\n                surrounding.add(nodeB);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n  }\n  for (i = 0; i < nodeA.surrounding.length; i++) {\n    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n  }\n};\n\nFDLayout.prototype.calcRepulsionRange = function () {\n  return 0.0;\n};\n\nmodule.exports = FDLayout;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LEdge = __webpack_require__(1);\nvar FDLayoutConstants = __webpack_require__(7);\n\nfunction FDLayoutEdge(source, target, vEdge) {\n  LEdge.call(this, source, target, vEdge);\n  this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n}\n\nFDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\nfor (var prop in LEdge) {\n  FDLayoutEdge[prop] = LEdge[prop];\n}\n\nmodule.exports = FDLayoutEdge;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LNode = __webpack_require__(3);\n\nfunction FDLayoutNode(gm, loc, size, vNode) {\n  // alternative constructor is handled inside LNode\n  LNode.call(this, gm, loc, size, vNode);\n  //Spring, repulsion and gravitational forces acting on this node\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  //Amount by which this node is to be moved in this iteration\n  this.displacementX = 0;\n  this.displacementY = 0;\n\n  //Start and finish grid coordinates that this node is fallen into\n  this.startX = 0;\n  this.finishX = 0;\n  this.startY = 0;\n  this.finishY = 0;\n\n  //Geometric neighbors of this node\n  this.surrounding = [];\n}\n\nFDLayoutNode.prototype = Object.create(LNode.prototype);\n\nfor (var prop in LNode) {\n  FDLayoutNode[prop] = LNode[prop];\n}\n\nFDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\n  this.startX = _startX;\n  this.finishX = _finishX;\n  this.startY = _startY;\n  this.finishY = _finishY;\n};\n\nmodule.exports = FDLayoutNode;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction DimensionD(width, height) {\n  this.width = 0;\n  this.height = 0;\n  if (width !== null && height !== null) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nDimensionD.prototype.getWidth = function () {\n  return this.width;\n};\n\nDimensionD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nDimensionD.prototype.getHeight = function () {\n  return this.height;\n};\n\nDimensionD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nmodule.exports = DimensionD;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __webpack_require__(14);\n\nfunction HashMap() {\n  this.map = {};\n  this.keys = [];\n}\n\nHashMap.prototype.put = function (key, value) {\n  var theId = UniqueIDGeneretor.createID(key);\n  if (!this.contains(theId)) {\n    this.map[theId] = value;\n    this.keys.push(key);\n  }\n};\n\nHashMap.prototype.contains = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[key] != null;\n};\n\nHashMap.prototype.get = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[theId];\n};\n\nHashMap.prototype.keySet = function () {\n  return this.keys;\n};\n\nmodule.exports = HashMap;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __webpack_require__(14);\n\nfunction HashSet() {\n  this.set = {};\n}\n;\n\nHashSet.prototype.add = function (obj) {\n  var theId = UniqueIDGeneretor.createID(obj);\n  if (!this.contains(theId)) this.set[theId] = obj;\n};\n\nHashSet.prototype.remove = function (obj) {\n  delete this.set[UniqueIDGeneretor.createID(obj)];\n};\n\nHashSet.prototype.clear = function () {\n  this.set = {};\n};\n\nHashSet.prototype.contains = function (obj) {\n  return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n};\n\nHashSet.prototype.isEmpty = function () {\n  return this.size() === 0;\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\n//concats this.set to the given list\nHashSet.prototype.addAllTo = function (list) {\n  var keys = Object.keys(this.set);\n  var length = keys.length;\n  for (var i = 0; i < length; i++) {\n    list.push(this.set[keys[i]]);\n  }\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\nHashSet.prototype.addAll = function (list) {\n  var s = list.length;\n  for (var i = 0; i < s; i++) {\n    var v = list[i];\n    this.add(v);\n  }\n};\n\nmodule.exports = HashSet;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LinkedList = __webpack_require__(11);\n\nvar Quicksort = function () {\n    function Quicksort(A, compareFunction) {\n        _classCallCheck(this, Quicksort);\n\n        if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n\n        var length = void 0;\n        if (A instanceof LinkedList) length = A.size();else length = A.length;\n\n        this._quicksort(A, 0, length - 1);\n    }\n\n    _createClass(Quicksort, [{\n        key: '_quicksort',\n        value: function _quicksort(A, p, r) {\n            if (p < r) {\n                var q = this._partition(A, p, r);\n                this._quicksort(A, p, q);\n                this._quicksort(A, q + 1, r);\n            }\n        }\n    }, {\n        key: '_partition',\n        value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n            var i = p;\n            var j = r;\n            while (true) {\n                while (this.compareFunction(x, this._get(A, j))) {\n                    j--;\n                }while (this.compareFunction(this._get(A, i), x)) {\n                    i++;\n                }if (i < j) {\n                    this._swap(A, i, j);\n                    i++;\n                    j--;\n                } else return j;\n            }\n        }\n    }, {\n        key: '_get',\n        value: function _get(object, index) {\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\n        }\n    }, {\n        key: '_set',\n        value: function _set(object, index, value) {\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\n        }\n    }, {\n        key: '_swap',\n        value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n            this._set(A, i, this._get(A, j));\n            this._set(A, j, temp);\n        }\n    }, {\n        key: '_defaultCompareFunction',\n        value: function _defaultCompareFunction(a, b) {\n            return b > a;\n        }\n    }]);\n\n    return Quicksort;\n}();\n\nmodule.exports = Quicksort;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */\n\nvar NeedlemanWunsch = function () {\n    function NeedlemanWunsch(sequence1, sequence2) {\n        var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n        var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n        _classCallCheck(this, NeedlemanWunsch);\n\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.match_score = match_score;\n        this.mismatch_penalty = mismatch_penalty;\n        this.gap_penalty = gap_penalty;\n\n        // Just the remove redundancy\n        this.iMax = sequence1.length + 1;\n        this.jMax = sequence2.length + 1;\n\n        // Grid matrix of scores\n        this.grid = new Array(this.iMax);\n        for (var i = 0; i < this.iMax; i++) {\n            this.grid[i] = new Array(this.jMax);\n\n            for (var j = 0; j < this.jMax; j++) {\n                this.grid[i][j] = 0;\n            }\n        }\n\n        // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n        this.tracebackGrid = new Array(this.iMax);\n        for (var _i = 0; _i < this.iMax; _i++) {\n            this.tracebackGrid[_i] = new Array(this.jMax);\n\n            for (var _j = 0; _j < this.jMax; _j++) {\n                this.tracebackGrid[_i][_j] = [null, null, null];\n            }\n        }\n\n        // The aligned sequences (return multiple possibilities)\n        this.alignments = [];\n\n        // Final alignment score\n        this.score = -1;\n\n        // Calculate scores and tracebacks\n        this.computeGrids();\n    }\n\n    _createClass(NeedlemanWunsch, [{\n        key: \"getScore\",\n        value: function getScore() {\n            return this.score;\n        }\n    }, {\n        key: \"getAlignments\",\n        value: function getAlignments() {\n            return this.alignments;\n        }\n\n        // Main dynamic programming procedure\n\n    }, {\n        key: \"computeGrids\",\n        value: function computeGrids() {\n            // Fill in the first row\n            for (var j = 1; j < this.jMax; j++) {\n                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                this.tracebackGrid[0][j] = [false, false, true];\n            }\n\n            // Fill in the first column\n            for (var i = 1; i < this.iMax; i++) {\n                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                this.tracebackGrid[i][0] = [false, true, false];\n            }\n\n            // Fill the rest of the grid\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n                for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                    var diag = void 0;\n                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n\n                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n\n                    // If there exists multiple max values, capture them for multiple paths\n                    var maxOf = [diag, up, left];\n                    var indices = this.arrayAllMaxIndexes(maxOf);\n\n                    // Update Grids\n                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                    this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n                }\n            }\n\n            // Update alignment score\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n        }\n\n        // Gets all possible valid sequence combinations\n\n    }, {\n        key: \"alignmentTraceback\",\n        value: function alignmentTraceback() {\n            var inProcessAlignments = [];\n\n            inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],\n                seq1: \"\",\n                seq2: \"\"\n            });\n\n            while (inProcessAlignments[0]) {\n                var current = inProcessAlignments[0];\n                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n\n                if (directions[0]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n                if (directions[1]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: '-' + current.seq2\n                    });\n                }\n                if (directions[2]) {\n                    inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],\n                        seq1: '-' + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n\n                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,\n                    sequence2: current.seq2\n                });\n\n                inProcessAlignments.shift();\n            }\n\n            return this.alignments;\n        }\n\n        // Helper Functions\n\n    }, {\n        key: \"getAllIndexes\",\n        value: function getAllIndexes(arr, val) {\n            var indexes = [],\n                i = -1;\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\n                indexes.push(i);\n            }\n            return indexes;\n        }\n    }, {\n        key: \"arrayAllMaxIndexes\",\n        value: function arrayAllMaxIndexes(array) {\n            return this.getAllIndexes(array, Math.max.apply(null, array));\n        }\n    }]);\n\n    return NeedlemanWunsch;\n}();\n\nmodule.exports = NeedlemanWunsch;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar layoutBase = function layoutBase() {\n  return;\n};\n\nlayoutBase.FDLayout = __webpack_require__(18);\nlayoutBase.FDLayoutConstants = __webpack_require__(7);\nlayoutBase.FDLayoutEdge = __webpack_require__(19);\nlayoutBase.FDLayoutNode = __webpack_require__(20);\nlayoutBase.DimensionD = __webpack_require__(21);\nlayoutBase.HashMap = __webpack_require__(22);\nlayoutBase.HashSet = __webpack_require__(23);\nlayoutBase.IGeometry = __webpack_require__(8);\nlayoutBase.IMath = __webpack_require__(9);\nlayoutBase.Integer = __webpack_require__(10);\nlayoutBase.Point = __webpack_require__(12);\nlayoutBase.PointD = __webpack_require__(4);\nlayoutBase.RandomSeed = __webpack_require__(16);\nlayoutBase.RectangleD = __webpack_require__(13);\nlayoutBase.Transform = __webpack_require__(17);\nlayoutBase.UniqueIDGeneretor = __webpack_require__(14);\nlayoutBase.Quicksort = __webpack_require__(24);\nlayoutBase.LinkedList = __webpack_require__(11);\nlayoutBase.LGraphObject = __webpack_require__(2);\nlayoutBase.LGraph = __webpack_require__(5);\nlayoutBase.LEdge = __webpack_require__(1);\nlayoutBase.LGraphManager = __webpack_require__(6);\nlayoutBase.LNode = __webpack_require__(3);\nlayoutBase.Layout = __webpack_require__(15);\nlayoutBase.LayoutConstants = __webpack_require__(0);\nlayoutBase.NeedlemanWunsch = __webpack_require__(25);\n\nmodule.exports = layoutBase;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Emitter() {\n  this.listeners = [];\n}\n\nvar p = Emitter.prototype;\n\np.addListener = function (event, callback) {\n  this.listeners.push({\n    event: event,\n    callback: callback\n  });\n};\n\np.removeListener = function (event, callback) {\n  for (var i = this.listeners.length; i >= 0; i--) {\n    var l = this.listeners[i];\n\n    if (l.event === event && l.callback === callback) {\n      this.listeners.splice(i, 1);\n    }\n  }\n};\n\np.emit = function (event, data) {\n  for (var i = 0; i < this.listeners.length; i++) {\n    var l = this.listeners[i];\n\n    if (event === l.event) {\n      l.callback(data);\n    }\n  }\n};\n\nmodule.exports = Emitter;\n\n/***/ })\n/******/ ]);\n});"],"sourceRoot":""}